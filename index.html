<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SNV Lifetime Courts Schedule</title>
  <!-- Add Chart.js for plotting -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Add html2canvas for capturing plot as image -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<style>
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 2rem;
      background: linear-gradient(135deg, #f0f4ff, #e0ecff);
      color: #333;
    }
    /* Mobile-friendly styles */
    @media (max-width: 768px) {
      body {
        padding: 0.5rem;
      }
      h1 {
        font-size: 1.4rem;
        text-align: center;
        margin: 0.5rem 0;
      }
    }
    .tab-buttons {
      position: fixed;
      bottom: 24px;
      left: 24px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: #6366f1;
      border-radius: 50%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: all 0.3s ease;
      max-height: 80vh;
      overflow-y: auto;
      width: 80px;
      height: 80px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .tab-buttons.expanded {
      border-radius: 20px;
      width: auto;
      height: auto;
      padding: 10px;
      background: rgba(255, 255, 255, 0.9);
      -webkit-backdrop-filter: blur(5px);
      backdrop-filter: blur(5px);
    }
    
    .tab-buttons::before {
      content: attr(data-day);
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.2rem;
      color: white;
      cursor: pointer;
      z-index: 1001;
      font-weight: 600;
      text-align: center;
      width: 100%;
    }
    
    .tab-buttons.expanded::before {
      content: "✕";
      font-size: 1.2rem;
      left: 10px;
      transform: translateY(-50%);
      color: #333;
      width: auto;
    }
    
    /* Mobile tab buttons */
    @media (max-width: 768px) {
      .tab-buttons {
        bottom: 16px;
        left: 16px;
        width: 60px;
        height: 60px;
      }
      .tab-buttons::before {
        font-size: 1rem;
      }
    }
    
    .tab-buttons button {
      padding: 8px 15px;
      background: #c7d2fe;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      opacity: 0;
      transform: translateX(-20px);
      pointer-events: none;
      margin-left: 25px;
      display: none;
    }
    
    .tab-buttons.expanded button {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
      display: block;
    }
    
    .tab-buttons button.active {
      background: #6366f1;
      color: white;
    }
    
    .tab-buttons button:hover {
      transform: scale(1.05);
      background: #4f46e5;
    }
    
    .tab-buttons button::after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }
    
    .tab-buttons:active::after {
      transform: scale(2);
      opacity: 1;
      transition: 0s;
    }
    
    .day-section {
      display: none;
      animation: fadeSlide 0.5s ease;
    }
    
    .day-section.active {
      display: block;
    }
    
    @keyframes fadeSlide {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .date-title {
      font-size: 1.6rem;
      color: #4f46e5;
      margin: 2rem 0 1rem;
      padding-left: 8px;
      border-left: 4px solid #6366f1;
    }
    /* Mobile date title */
    @media (max-width: 768px) {
      .date-title {
        font-size: 1.2rem;
        margin: 1rem 0 0.5rem;
      }
    }
    table {
      width: 100%;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border-collapse: collapse;
      font-size: 1.2rem;
    }
    /* Responsive tables for mobile */
    @media (max-width: 768px) {
      table {
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
      }
    }
    th, td {
      padding: 14px;
      text-align: center;
    }
    @media (max-width: 768px) {
      th, td {
        padding: 8px 4px;
      }
    }
    th {
      background: #4f46e5;
      color: white;
      text-transform: uppercase;
    }
    tr:nth-child(even) td {
      background-color: #eef2ff;
    }
    .buttons-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    /* Adjust buttons for mobile */
    @media (max-width: 768px) {
      .buttons-container {
        bottom: 16px;
        right: 16px;
        gap: 12px;
      }
    }
    .action-button {
      width: 80px;
      height: 80px;
      background: #6366f1;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    @media (max-width: 768px) {
      .action-button {
        width: 60px;
        height: 60px;
        font-size: 1.5rem;
      }
    }
    .action-button:hover {
      transform: scale(1.05);
      background: #4f46e5;
    }
    .action-button::after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }
    .action-button:active::after {
      transform: scale(2);
      opacity: 1;
      transition: 0s;
    }
    .copy-toast {
      position: fixed;
      bottom: 110px;
      right: 24px;
      background: rgba(79,70,229,0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 30px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.4s;
    }
    @media (max-width: 768px) {
      .copy-toast {
        bottom: 85px;
        right: 16px;
        padding: 8px 16px;
        font-size: 0.9rem;
      }
    }
    .plot-container {
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      margin-bottom: 3rem;
      height: auto;
      min-height: 700px;
      overflow-y: visible;
      overflow-x: auto;
    }
    /* Mobile-specific plot container adjustments */
    @media (max-width: 768px) {
      .plot-container {
        padding: 8px;
        min-height: 500px;
        margin-bottom: 1.5rem;
      }
    }
    .view-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .view-toggle button {
      padding: 8px 16px;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      cursor: pointer;
    }
    @media (max-width: 768px) {
      .view-toggle button {
        padding: 6px 12px;
        font-size: 0.9rem;
      }
    }
    .view-toggle button.active {
      background: #c7d2fe;
      font-weight: bold;
    }
    .view-toggle button:first-child {
      border-radius: 20px 0 0 20px;
    }
    .view-toggle button:last-child {
      border-radius: 0 20px 20px 0;
    }
    .location-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 0 auto 15px;
      justify-content: center;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      max-width: 90%;
      border: 1px solid #e2e8f0;
    }
    @media (max-width: 768px) {
      .location-legend {
        padding: 8px;
        gap: 8px;
        margin-bottom: 10px;
      }
    }
    .legend-item {
      display: flex;
      align-items: center;
      font-size: 0.9rem;
      font-weight: 500;
      padding: 4px 8px;
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    @media (max-width: 768px) {
      .legend-item {
        font-size: 0.8rem;
        padding: 3px 6px;
      }
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      margin-right: 6px;
    }
    @media (max-width: 768px) {
      .legend-color {
        width: 10px;
        height: 10px;
        margin-right: 4px;
      }
    }
    .axis-title {
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      color: #4f46e5;
      margin: 5px 0;
    }
    @media (max-width: 768px) {
      .axis-title {
        font-size: 0.9rem;
        margin: 3px 0;
      }
    }
    .week-indicator {
      font-weight: bold;
      margin-left: 4px;
      color: #ff5722;
    }
    /* Adjust plot size for mobile */
    @media (max-width: 768px) {
      #schedule-plot {
        max-width: 100%;
      }
    }
    /* Add this at the bottom to ensure it's applied */
    @media (max-width: 768px) {
      /* Fix horizontal scrolling issues on mobile */
      .plot-container::-webkit-scrollbar {
        height: 6px;
      }
      .plot-container::-webkit-scrollbar-thumb {
        background-color: rgba(99, 102, 241, 0.5);
        border-radius: 3px;
      }
      .plot-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
      }
    }
  </style>
</head>
<body>
  <h1>SNV Lifetime Courts Schedule</h1>
  
  <div id="tab-buttons" class="tab-buttons"></div>
  
  <div class="view-toggle">
    <button id="table-view-btn" class="active">Table View</button>
    <button id="plot-view-btn">Schedule Plot</button>
  </div>
  
  <div id="table-container">Loading table...</div>
  <div id="plot-container" class="plot-container" style="display:none;">
    <div id="location-legend" class="location-legend"></div>
    <canvas id="schedule-plot"></canvas>
  </div>
  <div id="original-table" style="display:none;"></div>
<div style="text-align:center; margin: 2rem 0 0 0;">
  <a href="https://docs.google.com/spreadsheets/d/1zpnq9KvS73oZ8SK1JbUaBuK9u9nv_3NArXW1Hy7Pkzs/edit?gid=0#gid=0" target="_blank" rel="noopener" style="background:#4f46e5; color:white; padding:10px 20px; border:none; border-radius:20px; font-weight:600; cursor:pointer; text-decoration:none; display:inline-block;">Show Original Data</a>
</div>
  <div class="buttons-container">
    <button id="copy-button" class="action-button" title="Copy Current Tab">📋</button>
    <button id="copy-plot-button" class="action-button" title="Copy Plot as Image" style="display:none;">📊</button>
  </div>

<script>
const csvUrl = "https://corsproxy.io/?https://docs.google.com/spreadsheets/d/1zpnq9KvS73oZ8SK1JbUaBuK9u9nv_3NArXW1Hy7Pkzs/export?format=csv";

// Helper function to process court numbers
function processCourt(courtStr) {
  if (!courtStr) return ['Ct1']; // Default to court 1 if no valid data
  
  // Remove any non-essential characters, preserving numbers, commas, and hyphens
  const cleaned = courtStr.replace(/[^0-9,\-]/g, '').trim();
  if (!cleaned) return ['Ct1']; // Default to court 1 if no valid data
  
  // Process the cleaned string to extract all court numbers
  const courts = [];
  
  // Split by commas first
  const segments = cleaned.split(',').map(s => s.trim()).filter(s => s);
  
  segments.forEach(segment => {
    // Check if segment contains a range (e.g., "1-5")
    if (segment.includes('-')) {
      const [start, end] = segment.split('-').map(n => parseInt(n.trim()));
      // Validate that we have valid start/end numbers
      if (!isNaN(start) && !isNaN(end) && start <= end) {
        // Generate all numbers in the range
        for (let i = start; i <= end; i++) {
          courts.push(i.toString());
        }
      } else {
        // Invalid range, just add as is
        courts.push(segment);
      }
    } 
    // Check if segment is a multi-digit number that should be split (like "123")
    else if (segment.length > 1 && /^[1-9]+$/.test(segment)) {
      // Split into individual digits
      segment.split('').forEach(digit => courts.push(digit));
    }
    else {
      // Regular number, add as is
      courts.push(segment);
    }
  });
  
  // Return unique courts with "Ct" prefix
  return [...new Set(courts.map(c => `Ct${c}`))];
}

// Helper function to format courts compactly for display
function compactCourtsDisplay(courts) {
  if (courts.length <= 1) return courts.join(', ');
  
  // Extract court numbers for processing
  const numbers = courts.map(court => {
    const match = court.match(/(\d+)/);
    return match ? parseInt(match[1]) : null;
  }).filter(num => num !== null);
  
  if (numbers.length !== courts.length) {
    // Not all courts have numbers, just join them as is
    return courts.join(', ');
  }
  
  // Sort numbers
  numbers.sort((a, b) => a - b);
  
  // Find ranges
  const ranges = [];
  let rangeStart = numbers[0];
  let rangeEnd = numbers[0];
  
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i] === rangeEnd + 1) {
      // Continue the range
      rangeEnd = numbers[i];
    } else {
      // End the current range and start a new one
      if (rangeStart === rangeEnd) {
        ranges.push(`Ct${rangeStart}`);
      } else {
        ranges.push(`Ct${rangeStart}-${rangeEnd}`);
      }
      rangeStart = rangeEnd = numbers[i];
    }
  }
  
  // Add the last range
  if (rangeStart === rangeEnd) {
    ranges.push(`Ct${rangeStart}`);
  } else {
    ranges.push(`Ct${rangeStart}-${rangeEnd}`);
  }
  
  return ranges.join(', ');
}

// Helper function to clean and standardize a single time with context
function cleanSingleTime(timeStr, contextPeriod = null) {
  if (!timeStr) return '';
  
  console.log('cleanSingleTime input:', timeStr, 'context:', contextPeriod);
  
  // First, check if there's an explicit AM/PM in the input
  const explicitPeriodMatch = timeStr.match(/([AP]M)/i);
  let explicitPeriod = explicitPeriodMatch ? explicitPeriodMatch[1].toUpperCase() : null;
  
  console.log('Explicit period found:', explicitPeriod);
  
  // Remove all non-time characters except numbers and colon
  const cleanedTime = timeStr.replace(/[^0-9:]/g, '');
  
  console.log('After cleaning time part:', cleanedTime);
  
  if (!cleanedTime) return '';
  
  // Ensure minutes exist
  let timePart = cleanedTime;
  if (!timePart.includes(':')) {
    timePart = timePart + ':00';
  }
  
  // Parse hours and minutes
  const timeParts = timePart.split(':');
  if (timeParts.length < 2) return '';
  
  let hours = parseInt(timeParts[0]);
  let minutes = parseInt(timeParts[1]);
  
  console.log('Parsed hours:', hours, 'minutes:', minutes);
  
  // Validate hours and minutes are reasonable numbers
  if (isNaN(hours) || isNaN(minutes)) return '';
  if (hours < 0 || hours > 23) return '';
  if (minutes < 0 || minutes > 59) return '';
  
  // Determine the period to use (explicit takes priority over context)
  let period;
  if (explicitPeriod) {
    console.log('Using explicit period:', explicitPeriod);
    period = explicitPeriod;
  } else if (contextPeriod) {
    console.log('Using context period:', contextPeriod);
    period = contextPeriod;
  } else {
    // Only guess period if none exists and no context
    console.log('No period found, guessing based on hour...');
    
    // For times between 1-11, assume AM for morning times (7-11) and PM for afternoon times (1-6)
    if (hours >= 7 && hours <= 11) {
      period = 'AM';
    }
    else if (hours >= 1 && hours <= 6) {
      period = 'PM';
    }
    // For times 12, assume PM
    else if (hours === 12) {
      period = 'PM';
    }
    // For times 0, assume AM (midnight)
    else if (hours === 0) {
      period = 'AM';
    }
    // For other cases, assume AM
    else {
      period = 'AM';
    }
  }
  
  console.log('Final period:', period);
  
  // Ensure we're working with valid 12-hour format
  if (hours > 12) {
    // This shouldn't happen with proper input, but handle it
    hours = hours - 12;
    period = 'PM';
  }
  if (hours === 0) {
    hours = 12;
    period = 'AM';
  }
  
  // Format minutes
  minutes = minutes.toString().padStart(2, '0');
  
  const result = `${hours}:${minutes}${period}`;
  console.log('Final result:', result);
  
  return result;
}

// Helper function to convert 24-hour time to 12-hour format with period
function format24to12Hour(hour24) {
  let period = 'AM';
  let hour12 = hour24;
  
  if (hour24 >= 12) {
    period = 'PM';
    if (hour24 > 12) hour12 = hour24 - 12;
  }
  if (hour12 === 0) hour12 = 12;
  
  return { hour: hour12, period };
}

// Process a single time range (e.g. "1:30pm-3:30pm") with context
function processTimeRange(timeRange, contextPeriod = null) {
  if (!timeRange) return '';
  
  // Clean input and convert semicolons to colons first
  timeRange = timeRange.trim().replace(/;/g, ':');
  
  // Check if it's a time range with hyphen
  const parts = timeRange.split('-');
  
  // Process single time
  if (parts.length === 1) {
    const result = cleanSingleTime(parts[0], contextPeriod);
    if (result) {
      const periodMatch = result.match(/([AP]M)$/);
      const period = periodMatch ? periodMatch[1] : contextPeriod;
      return { result, period };
    }
    return '';
  }
  
  // Process time range
  if (parts.length === 2) {
    // Special handling: if the entire range ends with AM/PM (like "7-8:30pm"), 
    // that period should apply to the whole range
    const rangeEndPeriodMatch = timeRange.match(/([AP]M)\s*$/i);
    const rangeEndPeriod = rangeEndPeriodMatch ? rangeEndPeriodMatch[1].toUpperCase() : null;
    
    console.log(`Range "${timeRange}" - detected range period: ${rangeEndPeriod}`);
    
    // For start time: use range period if no explicit period, otherwise use context
    const hasStartExplicitPeriod = /[AP]M/i.test(parts[0]);
    let startContextPeriod = contextPeriod;
    if (!hasStartExplicitPeriod && rangeEndPeriod) {
      startContextPeriod = rangeEndPeriod;
    }
    
    const startTime = cleanSingleTime(parts[0], startContextPeriod);
    
    // Extract period from start time to use as context for end time
    const startMatch = startTime.match(/([AP]M)$/);
    const startPeriod = startMatch ? startMatch[1] : contextPeriod;
    
    // For end time, only use start period as context if the end time doesn't have explicit period
    const hasEndExplicitPeriod = /[AP]M/i.test(parts[1]);
    const endContextPeriod = hasEndExplicitPeriod ? null : startPeriod;
    
    const endTime = cleanSingleTime(parts[1], endContextPeriod);
    
    if (!startTime || !endTime) return '';
    
    console.log('processTimeRange - start:', startTime, 'end:', endTime);
    
    // Parse times for range validation
    const startTimeMatch = startTime.match(/(\d+):(\d+)([AP]M)/);
    const endTimeMatch = endTime.match(/(\d+):(\d+)([AP]M)/);
    
    if (!startTimeMatch || !endTimeMatch) return '';
    
    const [, startHour, startMinutes, startTimePeriod] = startTimeMatch;
    const [, endHour, endMinutes, endTimePeriod] = endTimeMatch;
    
    // Convert to 24-hour for range calculation
    let startHour24 = parseInt(startHour);
    let endHour24 = parseInt(endHour);
    
    if (startTimePeriod === 'PM' && startHour24 !== 12) startHour24 += 12;
    if (endTimePeriod === 'PM' && endHour24 !== 12) endHour24 += 12;
    if (startTimePeriod === 'AM' && startHour24 === 12) startHour24 = 0;
    if (endTimePeriod === 'AM' && endHour24 === 12) endHour24 = 0;
    
    console.log('24-hour times - start:', startHour24, 'end:', endHour24);
    
    // Calculate range length
    let rangeLength = endHour24 - startHour24;
    if (rangeLength < 0) rangeLength += 24;
    
    console.log('Range length:', rangeLength, 'hours');
    
    // Only adjust if the range is clearly invalid (> 12 hours)
    if (rangeLength > 12) {
      console.log('Range too long, adjusting...');
      // Calculate new end time (2 hours after start for reasonable default)
      let newEndHour24 = startHour24 + 2;
      if (newEndHour24 >= 24) newEndHour24 -= 24;
      
      // Convert back to 12-hour format
      const { hour: newEndHour, period: newEndPeriod } = format24to12Hour(newEndHour24);
      
      // Keep original minutes
      const adjustedResult = `${startTime}-${newEndHour}:${endMinutes}${newEndPeriod}`;
      console.log('Adjusted result:', adjustedResult);
      return { result: adjustedResult, period: startTimePeriod };
    }
    
    const result = `${startTime}-${endTime}`;
    console.log('Normal result:', result);
    return { result, period: startTimePeriod };
  }
  
  return '';
}

// Main time processing function for multiple time ranges
function processTime(timeStr) {
  if (!timeStr) return '';
  
  // Clean the input: remove trailing commas and extra whitespace
  timeStr = timeStr.replace(/,\s*$/, '').trim();
  
  // Split by commas, semicolons, OR ampersands for multiple time ranges
  // We'll use a regex to properly split by commas, semicolons, or ampersands that aren't part of time values
  const timeRanges = timeStr.split(/[,;&]\s*/).filter(range => range.trim());
  
  // Process each time range independently first to check for explicit periods
  const processedRanges = [];
  let contextPeriod = null;
  
  for (const range of timeRanges) {
    // Check if this range has explicit AM/PM - if so, don't use context
    const hasExplicitPeriod = /[AP]M/i.test(range);
    const useContext = !hasExplicitPeriod ? contextPeriod : null;
    
    console.log(`Processing range: "${range}", hasExplicit: ${hasExplicitPeriod}, useContext: ${useContext}`);
    
    const processed = processTimeRange(range.trim(), useContext);
    
    if (processed) {
      // Handle both string and object returns
      if (typeof processed === 'string') {
        processedRanges.push(processed);
        // Extract period for context - update only if we found a period
        const periodMatch = processed.match(/([AP]M)/);
        if (periodMatch) {
          contextPeriod = periodMatch[1];
        }
      } else if (processed.result) {
        processedRanges.push(processed.result);
        // Use the period from the processed result
        if (processed.period) {
          contextPeriod = processed.period;
        }
      }
    }
  }
  
  // Join back with commas
  return processedRanges.join(', ');
}

// Helper function to parse time string into hours (for plotting)
function parseTimeToHours(timeStr) {
  if (!timeStr) return null;
  
  const match = timeStr.match(/(\d+):(\d+)([AP]M)/);
  if (!match) return null;
  
  let [, hours, minutes, period] = match;
  hours = parseInt(hours);
  minutes = parseInt(minutes);
  
  // Convert to 24-hour format
  if (period === 'PM' && hours !== 12) hours += 12;
  if (period === 'AM' && hours === 12) hours = 0;
  
  // Return as decimal hours
  return hours + (minutes / 60);
}

// Extract time ranges for plotting
function extractTimeRanges(timeStr) {
  if (!timeStr) return [];
  
  // Clean the input: remove trailing commas and extra whitespace
  timeStr = timeStr.replace(/,\s*$/, '').trim();
  
  const ranges = [];
  const timeRanges = timeStr.split(/[,;&]\s*/).filter(range => range.trim());
  
  for (const range of timeRanges) {
    const parts = range.split('-');
    if (parts.length === 2) {
      const start = parseTimeToHours(parts[0]);
      const end = parseTimeToHours(parts[1]);
      
      if (start !== null && end !== null) {
        ranges.push({ start, end });
      }
    }
  }
  
  return ranges;
}

// Helper function to get week number
function getWeekNumber(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

async function fetchAndRenderTable() {
  const expectedDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const weekdayOrder = {"Monday":1,"Tuesday":2,"Wednesday":3,"Thursday":4,"Friday":5,"Saturday":6,"Sunday":7};

  const tabs = document.getElementById("tab-buttons");
  const container = document.getElementById("table-container");
  const originalTable = document.getElementById("original-table");
  // removed toggleBtn because link now directly opens external

  try {
    const response = await fetch(csvUrl);
    const csvText = await response.text();

    // Parse CSV properly using a more robust approach
    const parseCSV = (csv) => {
      const lines = csv.trim().split(/\r?\n/);
      return lines.map(line => {
        // Split by comma but respect quotes
        const result = [];
        let cell = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            result.push(cell.trim());
            cell = '';
          } else {
            cell += char;
          }
        }
        
        // Add the last cell
        result.push(cell.trim());
        return result;
      });
    };

    const rows = parseCSV(csvText);
    let rawData = [];

    let lastDay = "";
    let lastDate = "";
    let currentCourt = "";

    // First pass: collect raw data
    for (let row of rows) {
      // Ensure we have enough columns
      if (row.length < 5) continue;
      
      // Extract values and trim
      let [V1, V2, V3, V4, V5, V6] = row.map(cell => cell ? cell.trim() : '');
      
      // Skip header row
      if (V1 === "Day of the Week") continue;

      // Identify location rows
      if (V1 && !V2 && !V3 && !V4 && !expectedDays.includes(V1)) {
        currentCourt = V1.replace(/ Park| School|Sunnyvale Middle School \(|\)/g, "").trim();
        continue;
      }

      // Fill in missing values from previous rows
      if (!V1) V1 = lastDay; else lastDay = V1;
      if (!V2) V2 = lastDate; else lastDate = V2;

      // Skip non-valid days and empty court numbers
      if (!expectedDays.includes(V1)) continue;
      if (!V4) continue;

      // Debug: Log the court column value
      console.log('Court column V4:', V4, 'from row:', [V1, V2, V3, V4, V5, V6]);

      // Process date format
      let d = V2;
      let parts = d.split("/");
      if (parts.length === 2) {
        d = `${parts[0]}/${parts[1]}/2025`;
      } else if (parts.length === 3 && parts[2].length === 2) {
        d = `${parts[0]}/${parts[1]}/20${parts[2]}`;
      }
      let dateObj = new Date(d);
      
      // For each court in this row, create a separate entry with the time(s) from this row only
      let courtNumbers = processCourt(V4);
      console.log('Processed court numbers:', courtNumbers, 'from V4:', V4);
      
      courtNumbers.forEach(court => {
        rawData.push({
          Day: V1,
          Date: d,
          DateObj: dateObj,
          RawTime: V3,
          Time: processTime(V3),
          RawCourt: V4,
          Court: court,
          Location: currentCourt
        });
      });
    }
    
    // Second pass: combine times for the same court on the same date/location only if they are from the same row
    // (in this case, there should be only one time per court per row, but we keep the logic for safety)
    let cleaned = [];
    const combinedData = {};
    rawData.forEach(item => {
      const key = `${item.Day}|${item.Date}|${item.Location}|${item.Court}|${item.Time}`;
      if (!combinedData[key]) {
        combinedData[key] = {
          ...item,
          Times: [item.Time]
        };
      } else {
        if (!combinedData[key].Times.includes(item.Time)) {
          combinedData[key].Times.push(item.Time);
        }
      }
    });
    // Convert back to array and set combined time string
    cleaned = Object.values(combinedData).map(item => ({
      ...item,
      Time: item.Times.join(', ')
    }));

    console.log('Processed data sample:', cleaned.slice(0, 10));

    // Sort by day, date, location, court
    cleaned.sort((a, b) => {
      if (weekdayOrder[a.Day] !== weekdayOrder[b.Day]) 
        return weekdayOrder[a.Day] - weekdayOrder[b.Day];
      if (b.DateObj - a.DateObj !== 0) 
        return b.DateObj - a.DateObj;
      if (a.Location !== b.Location) 
        return a.Location.localeCompare(b.Location);
        
      // Extract court numbers for numeric comparison
      const aNum = parseInt(a.Court.replace(/\D/g, '')) || 0;
      const bNum = parseInt(b.Court.replace(/\D/g, '')) || 0;
      return aNum - bNum;
    });

    // Debug: Log some sample data to see what we have
    console.log('Sample cleaned data after sorting:', cleaned.slice(0, 5).map(item => ({
      Day: item.Day,
      Date: item.Date,
      Location: item.Location,
      Court: item.Court,
      Time: item.Time
    })));

    // Group for display
    const grouped = {};
    cleaned.forEach(row => {
      if (!grouped[row.Day]) grouped[row.Day] = {};
      if (!grouped[row.Day][row.Date]) grouped[row.Day][row.Date] = [];
      grouped[row.Day][row.Date].push(row);
    });

    container.innerHTML = "";
    tabs.innerHTML = "";

    // Generate plot data for current data
    let allPlotData = {};
    
    for (const day of expectedDays) {
      if (grouped[day]) {
        const btn = document.createElement("button");
        btn.textContent = day;
        btn.onclick = () => switchTab(day);
        tabs.appendChild(btn);

        const section = document.createElement("div");
        section.id = `section-${day}`;
        section.className = "day-section";

        // Initialize plot data for this day
        allPlotData[day] = [];

        for (const date of Object.keys(grouped[day]).sort((a, b) => new Date(b) - new Date(a))) {
          const dateTitle = document.createElement("div");
          dateTitle.className = "date-title";
          dateTitle.textContent = date;
          section.appendChild(dateTitle);

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");

          ["Location", "Courts", "Time"].forEach(header => {
            const th = document.createElement("th");
            th.textContent = header;
            headRow.appendChild(th);
          });

          thead.appendChild(headRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          
          // Group by location and time
          const locationTimeGroups = {};
          
          // Sort entries by location and court number
          grouped[day][date].sort((a, b) => {
            if (a.Location !== b.Location) return a.Location.localeCompare(b.Location);
            const aNum = parseInt(a.Court.replace(/\D/g, '')) || 0;
            const bNum = parseInt(b.Court.replace(/\D/g, '')) || 0;
            return aNum - bNum;
          }).forEach(row => {
            // Use the original row data to preserve court groupings from the same row
            const key = `${row.Location}|${row.Time}|${row.RawCourt}`;
            
            // Debug: Log what we're processing
            console.log('Processing row:', { location: row.Location, court: row.Court, time: row.Time, rawCourt: row.RawCourt, key: key });
            
            if (!locationTimeGroups[key]) {
              locationTimeGroups[key] = {
                location: row.Location,
                time: row.Time,
                courts: [row.Court],
                rawCourt: row.RawCourt
              };
            } else {
              // Add court if not already included
              if (!locationTimeGroups[key].courts.includes(row.Court)) {
                locationTimeGroups[key].courts.push(row.Court);
              }
            }
          });
          
          // Debug: Log the grouped data
          console.log('Location time groups for', date, ':', locationTimeGroups);
          
          // Sort by location
          Object.values(locationTimeGroups)
            .sort((a, b) => a.location.localeCompare(b.location))
            .forEach(group => {
              const tr = document.createElement("tr");
              
              // Sort and format the courts for display
              const sortedCourts = group.courts.sort((a, b) => {
                const aNum = parseInt(a.replace(/\D/g, '')) || 0;
                const bNum = parseInt(b.replace(/\D/g, '')) || 0;
                return aNum - bNum;
              });
              
              // Format courts compactly when possible
              const formattedCourts = compactCourtsDisplay(sortedCourts);
              
              [group.location, formattedCourts, group.time].forEach(cell => {
                const td = document.createElement("td");
                td.textContent = cell;
                tr.appendChild(td);
              });
              
              tbody.appendChild(tr);
              
              // Separate each court to own entry for plot visualization
              const timeRanges = extractTimeRanges(group.time);
              group.courts.forEach(court => {
                timeRanges.forEach(range => {
                  if (!allPlotData[day]) allPlotData[day] = [];
                  
                  // Add one data point per court per time range
                  allPlotData[day].push({
                    location: group.location,
                    court: court,
                    date: date,
                    startTime: range.start,
                    endTime: range.end
                  });
                });
              });
            });
          
          table.appendChild(tbody);
          section.appendChild(table);
        }

        container.appendChild(section);
      }
    }

    // build original data table
    const tableOrig = document.createElement("table");
    const theadOrig = document.createElement("thead");
    const headRowOrig = document.createElement("tr");
    ["Day", "Date", "Time", "Court", "Location"].forEach(header => {
      const th = document.createElement("th");
      th.textContent = header;
      headRowOrig.appendChild(th);
    });
    theadOrig.appendChild(headRowOrig);
    tableOrig.appendChild(theadOrig);
    const tbodyOrig = document.createElement("tbody");
    cleaned.forEach(row => {
      const tr = document.createElement("tr");
      [row.Day, row.Date, row.Time, row.Court, row.Location].forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        tr.appendChild(td);
      });
      tbodyOrig.appendChild(tr);
    });
    tableOrig.appendChild(tbodyOrig);
    originalTable.appendChild(tableOrig);

    let currentTab = "";
    
    // Create plot for schedule visualization
    function createPlot(day, forCopy = false) {
      if (!day) return;
      
      const plotContainer = document.getElementById('plot-container');
      const legendContainer = document.getElementById('location-legend');
      const canvas = document.getElementById('schedule-plot');
      const ctx = canvas.getContext('2d');
      
      // Clear any existing content
      legendContainer.innerHTML = '';
      
      // Use the original cleaned data instead of parsing the table
      // Get the original data from the hidden table
      const originalTable = document.getElementById('original-table');
      const rows = Array.from(originalTable.querySelectorAll('tbody tr'));
      
      // Filter rows for current day
      const dayData = rows.filter(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        return cells[0]?.textContent.trim() === day;
      });
      
      console.log(`Found ${dayData.length} rows for ${day}`);
      
      // Group by location and court
      const courts = new Map();
      
      dayData.forEach(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        if (cells.length < 5) return;
        
        const location = cells[4].textContent.trim();
        const court = cells[3].textContent.trim();
        const time = cells[2].textContent.trim();
        
        // Skip entries with no time data
        if (!time || time.trim() === '') {
          return;
        }
        
        const courtId = `${location}-${court}`;
        
        // Store the court if it's not already in our map
        if (!courts.has(courtId)) {
          courts.set(courtId, {
            id: courtId,
            location: location,
            court: court,
            label: `${location} - ${court}`,
            timeRanges: []
          });
        }
        
        // Parse time ranges from the original time data
        const timeRanges = extractTimeRanges(time);
        console.log(`Court ${court} at ${location}: time="${time}" -> ${timeRanges.length} ranges:`, timeRanges);
        
        // Debug: Show individual time parsing
        if (timeRanges.length === 0 && time) {
          console.log(`Failed to parse time ranges for "${time}"`);
          // Try to parse individual times to see what's wrong
          const individualTimes = time.split(/[,;&]\s*/).filter(t => t.trim());
          individualTimes.forEach(t => {
            const parsed = parseTimeToHours(t.trim());
            console.log(`  Individual time "${t.trim()}" -> ${parsed}`);
          });
        }
        
        // Add all time ranges for this court
        timeRanges.forEach(range => {
          courts.get(courtId).timeRanges.push({
            startTime: range.start,
            endTime: range.end
          });
        });
      });
      
      console.log(`Total courts found: ${courts.size}`);
      console.log('Courts data:', Array.from(courts.values()));
      
      // Convert to array and sort by location and court number
      const sortedCourts = Array.from(courts.values()).sort((a, b) => {
        if (a.location !== b.location) {
          return a.location.localeCompare(b.location);
        }
        
        // Extract and compare court numbers
        const aMatch = a.court.match(/(\d+)/);
        const bMatch = b.court.match(/(\d+)/);
        const aNum = aMatch ? parseInt(aMatch[1]) : 0;
        const bNum = bMatch ? parseInt(bMatch[1]) : 0;
        return aNum - bNum;
      });
      
      // Generate color map for locations
      const locations = [...new Set(sortedCourts.map(c => c.location))];
      const colorPalette = [
        '#2563eb', '#dc2626', '#059669', '#7c3aed', '#ea580c', 
        '#0284c7', '#9333ea', '#0891b2', '#ca8a04', '#be185d',
        '#4338ca', '#15803d', '#b91c1c', '#4f46e5', '#0f766e'
      ];
      
      const colorMap = {};
      locations.forEach((loc, i) => {
        colorMap[loc] = colorPalette[i % colorPalette.length];
      });
      
      // Create legend only for copy version
      if (forCopy) {
        const legendTitle = document.createElement('div');
        legendTitle.className = 'axis-title';
        legendTitle.textContent = 'Court Locations';
        legendContainer.appendChild(legendTitle);
        
        locations.forEach(location => {
          const legendItem = document.createElement('div');
          legendItem.className = 'legend-item';
          
          const colorBox = document.createElement('div');
          colorBox.className = 'legend-color';
          colorBox.style.backgroundColor = colorMap[location];
          
          const label = document.createElement('span');
          label.textContent = location;
          
          legendItem.appendChild(colorBox);
          legendItem.appendChild(label);
          legendContainer.appendChild(legendItem);
        });
      }
      
      // Set canvas size based on whether it's for copy or display
      let padding, canvasWidth, canvasHeight, rowHeight, pixelRatio;
      const isMobile = window.innerWidth <= 768;
      
      if (forCopy) {
        // High resolution version for copying with legend
        padding = { top: 40, right: 20, bottom: 20, left: 200 };
        canvasWidth = Math.max(plotContainer.clientWidth - 30, 1200);
        rowHeight = 40;
        
        if (isMobile) {
          padding.left = 100;
          padding.right = 10;
          padding.top = 30;
          padding.bottom = 15;
        }
        
        const calculatedHeight = sortedCourts.length * rowHeight + padding.top + padding.bottom;
        canvasHeight = Math.max(calculatedHeight, 650);
        pixelRatio = window.devicePixelRatio || 2;
      } else {
        // Interactive display version - fit to screen
        const containerWidth = plotContainer.clientWidth;
        const containerHeight = window.innerHeight - 200; // Leave space for header and controls
        
        padding = { top: 30, right: 15, bottom: 15, left: 150 };
        canvasWidth = containerWidth - 30;
        rowHeight = Math.max(25, Math.min(40, (containerHeight - padding.top - padding.bottom) / sortedCourts.length));
        
        if (isMobile) {
          padding.left = 80;
          padding.right = 10;
          padding.top = 20;
          padding.bottom = 10;
          rowHeight = Math.max(20, rowHeight);
        }
        
        canvasHeight = sortedCourts.length * rowHeight + padding.top + padding.bottom;
        pixelRatio = 1; // Lower resolution for display performance
      }
      
      canvas.width = canvasWidth * pixelRatio;
      canvas.height = canvasHeight * pixelRatio;
      canvas.style.width = `${canvasWidth}px`;
      canvas.style.height = `${canvasHeight}px`;
      ctx.scale(pixelRatio, pixelRatio);
      
      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Draw time axis
      const startHour = 6; // 6 AM
      const endHour = 23; // 11 PM
      const hourWidth = (canvasWidth - padding.left - padding.right) / (endHour - startHour);
      
      // Draw time labels
      ctx.fillStyle = '#333';
      ctx.font = isMobile ? 'bold 10px Arial' : (forCopy ? 'bold 14px Arial' : 'bold 12px Arial');
      ctx.textAlign = 'center';
      
      // Draw both top and bottom time axes
      const drawTimeAxis = (yPosition, isTop) => {
        for (let hour = startHour; hour <= endHour; hour++) {
          const x = padding.left + (hour - startHour) * hourWidth;
          const displayHour = hour <= 12 ? hour : hour - 12;
          const ampm = hour < 12 ? 'AM' : 'PM';
          
          // Show time labels based on screen space
          const showLabel = isMobile ? (hour % 2 === 0 || hour === startHour || hour === endHour) : true;
          if (showLabel) {
            ctx.fillText(`${displayHour} ${ampm}`, x, yPosition);
          }
          
          // Draw vertical grid line, dotted at 4 PM and 8 PM
          ctx.beginPath();
          if (hour === 16 || hour === 20) {
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
          } else {
            ctx.setLineDash([]);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
          }
          
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, canvasHeight - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw horizontal axis line
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;
        const lineOffset = isTop ? 15 : -15;
        ctx.moveTo(padding.left, yPosition + lineOffset);
        ctx.lineTo(canvasWidth - padding.right, yPosition + lineOffset);
        ctx.stroke();
        ctx.lineWidth = 1;
      };
      
      drawTimeAxis(canvasHeight - 10, false);
      drawTimeAxis(padding.top / 2, true);
      
      // Draw court names and time bars
      sortedCourts.forEach((court, index) => {
        const y = padding.top + index * rowHeight + rowHeight / 2;
        
        // Draw court label
        ctx.fillStyle = '#333';
        ctx.font = isMobile ? '9px Arial' : (forCopy ? '14px Arial' : '11px Arial');
        ctx.textAlign = 'right';
        
        // Abbreviate court label for mobile or non-copy version
        let displayLabel = court.label;
        if (isMobile || !forCopy) {
          displayLabel = displayLabel.replace('Fremont High School', 'Fremont');
          displayLabel = displayLabel.replace('Washington Park', 'Wash');
          displayLabel = displayLabel.replace('Ponderosa Park', 'Pond');
          displayLabel = displayLabel.replace('Sunnyvale Middle School', 'SMS');
          displayLabel = displayLabel.replace('Lakewood Park', 'Lakewood');
          displayLabel = displayLabel.replace('Serra Park', 'Serra');
          displayLabel = displayLabel.replace('Fairwood Park', 'Fairwood');
          displayLabel = displayLabel.replace('Ortega Park', 'Ortega');
          displayLabel = displayLabel.replace('Raynor Park', 'Raynor');
          displayLabel = displayLabel.replace('De Anza Park', 'DeAnza');
          displayLabel = displayLabel.replace('Sunnyvale Community Center', 'SCC');
          displayLabel = displayLabel.replace('Sunnyvale Tennis Center', 'STC');
          displayLabel = displayLabel.replace('Mango Park', 'Mango');
          displayLabel = displayLabel.replace('Location Mange', 'Mango');
        }
        
        ctx.fillText(displayLabel, padding.left - 5, y + 4);
        
        // Draw horizontal line for this court
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.beginPath();
        ctx.moveTo(padding.left, y + rowHeight / 2);
        ctx.lineTo(canvasWidth - padding.right, y + rowHeight / 2);
        ctx.stroke();
        
        // Draw time ranges for this court
        court.timeRanges.forEach(range => {
          const startX = padding.left + (range.startTime - startHour) * hourWidth;
          const endX = padding.left + (range.endTime - startHour) * hourWidth;
          const width = endX - startX;
          
          // Draw time bar
          ctx.fillStyle = colorMap[court.location];
          const barHeight = rowHeight - (forCopy ? 14 : 8);
          
          // Draw rounded rectangle
          const radius = barHeight / 2;
          const effectiveRadius = Math.min(radius, width / 2);
          
          ctx.beginPath();
          ctx.moveTo(startX + effectiveRadius, y - barHeight / 2);
          ctx.lineTo(endX - effectiveRadius, y - barHeight / 2);
          ctx.arcTo(endX, y - barHeight / 2, endX, y - barHeight / 2 + effectiveRadius, effectiveRadius);
          ctx.lineTo(endX, y + barHeight / 2 - effectiveRadius);
          ctx.arcTo(endX, y + barHeight / 2, endX - effectiveRadius, y + barHeight / 2, effectiveRadius);
          ctx.lineTo(startX + effectiveRadius, y + barHeight / 2);
          ctx.arcTo(startX, y + barHeight / 2, startX, y + barHeight / 2 - effectiveRadius, effectiveRadius);
          ctx.lineTo(startX, y - barHeight / 2 + effectiveRadius);
          ctx.arcTo(startX, y - barHeight / 2, startX + effectiveRadius, y - barHeight / 2, effectiveRadius);
          
          ctx.closePath();
          ctx.fill();
          
          // Draw border
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
          ctx.stroke();
        });
      });
      
      // Only add time axis title for copy version
      if (forCopy) {
        const timeAxisTitle = document.createElement('div');
        timeAxisTitle.className = 'axis-title';
        timeAxisTitle.textContent = '';
        legendContainer.appendChild(timeAxisTitle);
      }
    }

    function switchTab(day) {
      document.querySelectorAll('.day-section').forEach(sec => sec.classList.remove('active'));
      document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`section-${day}`).classList.add('active');
      Array.from(tabs.children).find(btn => btn.textContent === day).classList.add('active');
      currentTab = day;
      
      // Update the button text with abbreviation
      document.querySelector('.tab-buttons').setAttribute('data-day', day.substring(0, 3));
      
      // Check if we're in plot view
      const isPlotView = document.getElementById('plot-view-btn').classList.contains('active');
      
      // Set display based on current view
      if (isPlotView) {
        container.style.display = "none";
        document.getElementById('plot-container').style.display = "block";
        document.getElementById('copy-plot-button').style.display = "flex";
        createPlot(day, false); // Display version without legend
      } else {
        container.style.display = "block";
        document.getElementById('plot-container').style.display = "none";
        document.getElementById('copy-plot-button').style.display = "none";
      }
      
      originalTable.style.display = "none";
    }

    // Improved copy function for better formatting
    document.getElementById("copy-button").addEventListener("click", () => {
      if (!currentTab) return;
      
      // Get today's date for comparison
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Helper function to simplify location names
      function simplifyLocation(location) {
        return location
          .replace('Fremont High School', 'Fremont')
          .replace('Washington Park', 'Wash')
          .replace('Ponderosa Park', 'Pond')
          .replace('Sunnyvale Middle School', 'SMS')
          .replace('Lakewood Park', 'Lakewood')
          .replace('Serra Park', 'Serra')
          .replace('Fairwood Park', 'Fairwood')
          .replace('Ortega Park', 'Ortega')
          .replace('Raynor Park', 'Raynor')
          .replace('De Anza Park', 'DeAnza')
          .replace('Sunnyvale Community Center', 'SCC')
          .replace('Sunnyvale Tennis Center', 'STC')
          .replace('Mango Park', 'Mango')
          .replace('Location Mange', 'Mango');
      }
      
      // Helper function to normalize date format
      function normalizeDate(dateStr) {
        const parts = dateStr.split('/');
        const month = parseInt(parts[0]);
        const day = parseInt(parts[1]);
        const year = parts[2] ? parseInt(parts[2]) : new Date().getFullYear();
        return `${month}/${day}/${year}`;
      }
      
      // Get the original data from the hidden table
      const originalTable = document.getElementById('original-table');
      const rows = Array.from(originalTable.querySelectorAll('tbody tr'));
      
      // Filter rows for current day
      const dayData = rows.filter(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        return cells[0]?.textContent.trim() === currentTab;
      });
      
      // Group by normalized date
      const dateGroups = {};
      dayData.forEach(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        const date = normalizeDate(cells[1].textContent.trim());
        const location = cells[4].textContent.trim();
        const court = cells[3].textContent.trim();
        const time = cells[2].textContent.trim();
        
        // Skip entries with no time data
        if (!time || time.trim() === '') {
          return;
        }
        
        if (!dateGroups[date]) {
          dateGroups[date] = {};
        }
        if (!dateGroups[date][location]) {
          dateGroups[date][location] = [];
        }
        dateGroups[date][location].push({ court, time });
      });
      
      let todayData = '';
      let otherData = '';
      let todayDateDisplay = '';
      
      // Process each date group
      Object.entries(dateGroups).forEach(([date, locations]) => {
        // Parse date
        const dateParts = date.split('/');
        const month = parseInt(dateParts[0]);
        const day = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        
        const dateObj = new Date(year, month - 1, day);
        dateObj.setHours(0, 0, 0, 0);
        
        // Format date for display
        const dateDisplay = `${month}/${day}`;
        
        // Add date with parentheses if not today
        const isToday = dateObj.getTime() === today.getTime();
        const datePrefix = isToday ? '' : `(${dateDisplay})`;
        
        if (isToday) {
          todayDateDisplay = dateDisplay;
        }
        
        // Process each location
        const sortedLocations = Object.keys(locations).sort();
        let sectionText = '';
        
        sortedLocations.forEach((location, index) => {
          const locationData = locations[location];
          
          // Mango Park is now available - process normally
          // (removed special unavailable handling)
          
          // Group by time and filter out empty times
          const timeGroups = {};
          locationData.forEach(item => {
            // Skip items with no valid time
            if (!item.time || item.time.trim() === '') {
              return;
            }
            if (!timeGroups[item.time]) {
              timeGroups[item.time] = [];
            }
            timeGroups[item.time].push(item.court);
          });
          
          const timeEntries = Object.entries(timeGroups);
          
          // Skip locations with no valid time entries
          if (timeEntries.length === 0) {
            return;
          }
          
          const simpleLocation = simplifyLocation(location);
          
          if (timeEntries.length === 1) {
            const [time, courts] = timeEntries[0];
            sectionText += `${simpleLocation}${datePrefix}: ${courts.join(', ')}: ${time}\n`;
          } else {
            sectionText += `${simpleLocation}${datePrefix}:\n`;
            timeEntries.forEach(([time, courts]) => {
              sectionText += `  ${courts.join(', ')}: ${time}\n`;
            });
          }
          
          if (index < sortedLocations.length - 1) {
            sectionText += '\n';
          }
        });
        
        if (isToday) {
          todayData = sectionText;
        } else {
          otherData += sectionText;
        }
      });
      
      const text = `SNV LT 教练占场信息 ${currentTab} ${todayDateDisplay}\n${todayData}${otherData}`;
      
      navigator.clipboard.writeText(text).then(() => {
        document.getElementById("copy-toast").style.opacity = 1;
        setTimeout(() => { document.getElementById("copy-toast").style.opacity = 0; }, 1500);
      });
    });
    
    // Add handler for plot copying
    document.getElementById("copy-plot-button").addEventListener("click", () => {
      if (!currentTab) {
        alert("Please select a day and switch to plot view first");
        return;
      }
      
      // Show a brief loading message
      const plotToast = document.getElementById("plot-toast");
      plotToast.textContent = "Creating high-res plot...";
      plotToast.style.opacity = 1;
      
      // Create a complete temporary plot environment
      const tempContainer = document.createElement('div');
      tempContainer.style.position = 'absolute';
      tempContainer.style.left = '-9999px';
      tempContainer.style.top = '-9999px';
      tempContainer.style.width = '1200px';
      tempContainer.style.height = '800px';
      tempContainer.id = 'temp-plot-container';
      
      const tempLegend = document.createElement('div');
      tempLegend.id = 'temp-location-legend';
      tempLegend.className = 'location-legend';
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.id = 'temp-schedule-plot';
      
      tempContainer.appendChild(tempLegend);
      tempContainer.appendChild(tempCanvas);
      document.body.appendChild(tempContainer);
      
      // Store original element references
      const originalCanvas = document.getElementById('schedule-plot');
      const originalContainer = document.getElementById('plot-container');
      const originalLegend = document.getElementById('location-legend');
      
      try {
        // Temporarily replace the IDs so createPlot uses our temp elements
        originalCanvas.id = 'schedule-plot-backup';
        originalContainer.id = 'plot-container-backup';
        originalLegend.id = 'location-legend-backup';
        
        tempCanvas.id = 'schedule-plot';
        tempContainer.id = 'plot-container';
        tempLegend.id = 'location-legend';
        
        // Generate high-resolution plot for copying
        createPlot(currentTab, true);
        
        plotToast.textContent = "Copying plot...";
        
        // Detect if mobile
        const isMobile = window.innerWidth <= 768;
        
        // Convert to blob and copy
        tempCanvas.toBlob(blob => {
          if (blob) {
            // Always try clipboard first
            try {
              const item = new ClipboardItem({ "image/png": blob });
              navigator.clipboard.write([item]).then(() => {
                plotToast.textContent = "Copied plot ✅";
                setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
              }).catch(err => {
                console.error("Could not copy image to clipboard: ", err);
                // Fallback to download if clipboard fails
                fallbackToDownload(blob);
              });
            } catch (err) {
              console.error("Clipboard API not supported: ", err);
              // Fallback to download if clipboard API not supported
              fallbackToDownload(blob);
            }
          } else {
            console.error("Failed to create blob from canvas");
            plotToast.textContent = "Copy failed ❌";
            setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
          }
          
          // Restore original IDs
          originalCanvas.id = 'schedule-plot';
          originalContainer.id = 'plot-container';
          originalLegend.id = 'location-legend';
          
          // Clean up temporary elements
          document.body.removeChild(tempContainer);
          
          // Restore the interactive display plot
          createPlot(currentTab, false);
        }, 'image/png', 1.0);
        
      } catch (err) {
        console.error("Error generating copy plot:", err);
        plotToast.textContent = "Copy failed ❌";
        setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
        
        // Restore original IDs on error
        originalCanvas.id = 'schedule-plot';
        originalContainer.id = 'plot-container';
        originalLegend.id = 'location-legend';
        
        // Clean up on error
        document.body.removeChild(tempContainer);
      }
      
      // Fallback function to download if clipboard fails
      function fallbackToDownload(blob) {
        try {
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `tennis-courts-${currentTab.toLowerCase()}.png`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          
          plotToast.textContent = "Image downloaded ✅";
          setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
        } catch(err) {
          console.error("Download fallback failed:", err);
          plotToast.textContent = "Copy failed ❌";
          setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
        }
      }
    });
    
    // Toggle between table and plot views
    document.getElementById('table-view-btn').addEventListener('click', () => {
      document.getElementById('table-container').style.display = 'block';
      document.getElementById('plot-container').style.display = 'none';
      document.getElementById('table-view-btn').classList.add('active');
      document.getElementById('plot-view-btn').classList.remove('active');
      document.getElementById('copy-plot-button').style.display = 'none';
    });
    
    document.getElementById('plot-view-btn').addEventListener('click', () => {
      document.getElementById('table-container').style.display = 'none';
      document.getElementById('plot-container').style.display = 'block';
      document.getElementById('table-view-btn').classList.remove('active');
      document.getElementById('plot-view-btn').classList.add('active');
      document.getElementById('copy-plot-button').style.display = 'flex';
      
      if (currentTab) {
        createPlot(currentTab, false); // Display version without legend
      }
    });
    
    // Add window resize handler for responsive plot
    let resizeTimeout;
    window.addEventListener('resize', () => {
      // Debounce resize events
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Only recreate plot if we're currently viewing it
        const isPlotView = document.getElementById('plot-view-btn').classList.contains('active');
        if (isPlotView && currentTab) {
          createPlot(currentTab, false);
        }
      }, 250);
    });

    const today = new Date();
    const todayDay = expectedDays[today.getDay()];
    const defaultDay = grouped[todayDay] ? todayDay : expectedDays.find(day => grouped[day]);
    if (defaultDay) {
      switchTab(defaultDay);
      // Set the initial day text with abbreviation
      document.querySelector('.tab-buttons').setAttribute('data-day', defaultDay.substring(0, 3));
    }

  } catch (error) {
    console.error("Failed to fetch or render CSV:", error);
    document.getElementById("table-container").innerHTML = "Could not load schedule. Please check network or CSV URL.";
  }
}

// Test the time processing logic
console.log('=== Time Processing Tests ===');
console.log('Context test - Input: "4:15-7:15, 8:15-9:15"');
console.log('Context test - Output:', processTime("4:15-7:15, 8:15-9:15"));
console.log('Mixed periods test - Input: "8-10am, 5-6pm, 7-8:30pm"');
console.log('Mixed periods test - Output:', processTime("8-10am, 5-6pm, 7-8:30pm"));
console.log('Single range test - Input: "7-8:30pm"');
console.log('Single range test - Output:', processTime("7-8:30pm"));
console.log('Debug start time: "7" with PM context ->', cleanSingleTime("7", "PM"));
console.log('Debug end time: "8:30pm" ->', cleanSingleTime("8:30pm", null));
console.log('=== End Tests ===');

fetchAndRenderTable();

// Add this to your existing JavaScript
document.addEventListener('DOMContentLoaded', function() {
    const tabButtons = document.querySelector('.tab-buttons');
    
    // Add click handler for the expand/collapse button
    tabButtons.addEventListener('click', function(e) {
        if (e.target === this || e.target === this.firstElementChild) {
            this.classList.toggle('expanded');
        }
    });
    
    // Close the menu when clicking outside
    document.addEventListener('click', function(e) {
        if (!tabButtons.contains(e.target)) {
            tabButtons.classList.remove('expanded');
        }
    });
});
</script>
<div id="copy-toast" class="copy-toast">Copied text ✅</div>
<div id="plot-toast" class="copy-toast">Copied plot ✅</div>
</body>
</html>