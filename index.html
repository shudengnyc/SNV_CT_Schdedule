<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SNV Lifetime Courts Schedule</title>
  <!-- Add Chart.js for plotting -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Add html2canvas for capturing plot as image -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <!-- Add jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 2rem;
      background: linear-gradient(135deg, #f0f4ff, #e0ecff);
      color: #333;
    }
    /* Mobile-friendly styles */
    @media (max-width: 768px) {
      body {
        padding: 0.5rem;
      }
      h1 {
        font-size: 1.4rem;
        text-align: center;
        margin: 0.5rem 0;
      }
    }
    .tab-buttons {
      position: fixed;
      bottom: 24px;
      left: 24px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: #6366f1;
      border-radius: 50%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: all 0.3s ease;
      max-height: 80vh;
      overflow-y: auto;
      width: 80px;
      height: 80px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .tab-buttons.expanded {
      border-radius: 20px;
      width: auto;
      height: auto;
      padding: 10px;
      background: rgba(255, 255, 255, 0.9);
      -webkit-backdrop-filter: blur(5px);
      backdrop-filter: blur(5px);
    }
    
    .tab-buttons::before {
      content: attr(data-day);
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.2rem;
      color: white;
      cursor: pointer;
      z-index: 1001;
      font-weight: 600;
      text-align: center;
      width: 100%;
    }
    
    .tab-buttons.expanded::before {
      content: "âœ•";
      font-size: 1.2rem;
      left: 10px;
      transform: translateY(-50%);
      color: #333;
      width: auto;
    }
    
    /* Mobile tab buttons */
    @media (max-width: 768px) {
      .tab-buttons {
        bottom: 16px;
        left: 16px;
        width: 60px;
        height: 60px;
      }
      .tab-buttons::before {
        font-size: 1rem;
      }
    }
    
    .tab-buttons button {
      padding: 8px 15px;
      background: #c7d2fe;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      opacity: 0;
      transform: translateX(-20px);
      pointer-events: none;
      margin-left: 25px;
      display: none;
    }
    
    .tab-buttons.expanded button {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
      display: block;
    }
    
    .tab-buttons button.active {
      background: #6366f1;
      color: white;
    }
    
    .tab-buttons button:hover {
      transform: scale(1.05);
      background: #4f46e5;
    }
    
    .tab-buttons button::after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }
    
    .tab-buttons:active::after {
      transform: scale(2);
      opacity: 1;
      transition: 0s;
    }
    
    .day-section {
      display: none;
      animation: fadeSlide 0.5s ease;
    }
    
    .day-section.active {
      display: block;
    }
    
    @keyframes fadeSlide {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .date-title {
      font-size: 1.6rem;
      color: #4f46e5;
      margin: 2rem 0 1rem;
      padding-left: 8px;
      border-left: 4px solid #6366f1;
    }
    /* Mobile date title */
    @media (max-width: 768px) {
      .date-title {
        font-size: 1.2rem;
        margin: 1rem 0 0.5rem;
      }
    }
    table {
      width: 100%;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border-collapse: collapse;
      font-size: 1.2rem;
    }
    /* Responsive tables for mobile */
    @media (max-width: 768px) {
      table {
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
      }
    }
    th, td {
      padding: 14px;
      text-align: center;
    }
    @media (max-width: 768px) {
      th, td {
        padding: 8px 4px;
      }
    }
    th {
      background: #4f46e5;
      color: white;
      text-transform: uppercase;
    }
    tr:nth-child(even) td {
      background-color: #eef2ff;
    }
    .buttons-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    /* Adjust buttons for mobile */
    @media (max-width: 768px) {
      .buttons-container {
        bottom: 16px;
        right: 16px;
        gap: 12px;
      }
    }
    .action-button {
      width: 80px;
      height: 80px;
      background: #6366f1;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    @media (max-width: 768px) {
      .action-button {
        width: 60px;
        height: 60px;
        font-size: 1.5rem;
      }
    }
    .action-button:hover {
      transform: scale(1.05);
      background: #4f46e5;
    }
    .action-button::after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }
    .action-button:active::after {
      transform: scale(2);
      opacity: 1;
      transition: 0s;
    }
    .download-menu {
      position: absolute;
      bottom: 100%;
      right: 0;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
      z-index: 1000;
    }
    .download-option {
      padding: 8px 16px;
      background: #f3f4f6;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      white-space: nowrap;
      transition: all 0.2s ease;
    }
    .download-option:hover {
      background: #6366f1;
      color: white;
      transform: scale(1.05);
    }
    @media (max-width: 768px) {
      .download-menu {
        right: -10px;
        padding: 6px;
        gap: 6px;
      }
      .download-option {
        padding: 6px 12px;
        font-size: 0.8rem;
      }
    }
    .copy-toast {
      position: fixed;
      bottom: 110px;
      right: 24px;
      background: rgba(79,70,229,0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 30px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.4s;
    }
    @media (max-width: 768px) {
      .copy-toast {
        bottom: 85px;
        right: 16px;
        padding: 8px 16px;
        font-size: 0.9rem;
      }
    }
    .plot-container {
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      margin-bottom: 3rem;
      height: calc(100vh - 200px);
      min-height: 600px;
      max-height: 1000px;
      overflow: auto;
      display: flex;
      flex-direction: column;
    }
    /* Mobile-specific plot container adjustments */
    @media (max-width: 768px) {
      .plot-container {
        padding: 8px;
        height: calc(100vh - 150px);
        min-height: 400px;
        margin-bottom: 1.5rem;
      }
    }
    .view-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .view-toggle button {
      padding: 8px 16px;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      cursor: pointer;
    }
    @media (max-width: 768px) {
      .view-toggle button {
        padding: 6px 12px;
        font-size: 0.9rem;
      }
    }
    .view-toggle button.active {
      background: #c7d2fe;
      font-weight: bold;
    }
    .view-toggle button:first-child {
      border-radius: 20px 0 0 20px;
    }
    .view-toggle button:last-child {
      border-radius: 0 20px 20px 0;
    }
    .location-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 0 auto 15px;
      justify-content: center;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      max-width: 90%;
      border: 1px solid #e2e8f0;
    }
    @media (max-width: 768px) {
      .location-legend {
        padding: 8px;
        gap: 8px;
        margin-bottom: 10px;
      }
    }
    .legend-item {
      display: flex;
      align-items: center;
      font-size: 0.9rem;
      font-weight: 500;
      padding: 4px 8px;
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    @media (max-width: 768px) {
      .legend-item {
        font-size: 0.8rem;
        padding: 3px 6px;
      }
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      margin-right: 6px;
    }
    @media (max-width: 768px) {
      .legend-color {
        width: 10px;
        height: 10px;
        margin-right: 4px;
      }
    }
    .axis-title {
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      color: #4f46e5;
      margin: 5px 0;
    }
    @media (max-width: 768px) {
      .axis-title {
        font-size: 0.9rem;
        margin: 3px 0;
      }
    }
    .week-indicator {
      font-weight: bold;
      margin-left: 4px;
      color: #ff5722;
    }
    /* Improve canvas display */
    #schedule-plot {
      max-width: 100%;
      max-height: 100%;
      display: block;
      margin: 0 auto;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    /* Adjust plot size for mobile */
    @media (max-width: 768px) {
      #schedule-plot {
        max-width: 100%;
        border-radius: 4px;
      }
    }
    /* Add this at the bottom to ensure it's applied */
    @media (max-width: 768px) {
      /* Fix horizontal scrolling issues on mobile */
      .plot-container::-webkit-scrollbar {
        height: 6px;
      }
      .plot-container::-webkit-scrollbar-thumb {
        background-color: rgba(99, 102, 241, 0.5);
        border-radius: 3px;
      }
      .plot-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
      }
    }
  </style>
</head>
<body>
  <h1>SNV Lifetime Courts Schedule</h1>
  
  <div id="tab-buttons" class="tab-buttons"></div>
  
  <div class="view-toggle">
    <button id="table-view-btn" class="active">Table View</button>
    <button id="plot-view-btn">Schedule Plot</button>
  </div>
  
  <div id="table-container">Loading table...</div>
  <div id="plot-container" class="plot-container" style="display:none;">
    <div id="location-legend" class="location-legend"></div>
    <canvas id="schedule-plot"></canvas>
  </div>
  <div id="original-table" style="display:none;"></div>
<div style="text-align:center; margin: 2rem 0 0 0;">
  <a href="https://docs.google.com/spreadsheets/d/1zpnq9KvS73oZ8SK1JbUaBuK9u9nv_3NArXW1Hy7Pkzs/edit?gid=0#gid=0" target="_blank" rel="noopener" style="background:#4f46e5; color:white; padding:10px 20px; border:none; border-radius:20px; font-weight:600; cursor:pointer; text-decoration:none; display:inline-block;">Show Original Data</a>
</div>
  <div class="buttons-container">
    <button id="copy-button" class="action-button" title="Copy Current Tab">ðŸ“‹</button>
    <button id="copy-plot-button" class="action-button" title="Copy Plot to Clipboard" style="display:none;">ðŸ“‹</button>
  </div>

<script>
const csvUrl = "https://corsproxy.io/?https://docs.google.com/spreadsheets/d/1zpnq9KvS73oZ8SK1JbUaBuK9u9nv_3NArXW1Hy7Pkzs/export?format=csv";

// Helper function to process court numbers
function processCourt(courtStr) {
  if (!courtStr) return ['Ct1']; // Default to court 1 if no valid data
  
  // Remove any non-essential characters, preserving numbers, commas, and hyphens
  const cleaned = courtStr.replace(/[^0-9,\-]/g, '').trim();
  if (!cleaned) return ['Ct1']; // Default to court 1 if no valid data
  
  // Process the cleaned string to extract all court numbers
  const courts = [];
  
  // Split by commas first
  const segments = cleaned.split(',').map(s => s.trim()).filter(s => s);
  
  segments.forEach(segment => {
    // Check if segment contains a range (e.g., "1-5")
    if (segment.includes('-')) {
      const [start, end] = segment.split('-').map(n => parseInt(n.trim()));
      // Validate that we have valid start/end numbers
      if (!isNaN(start) && !isNaN(end) && start <= end) {
        // Generate all numbers in the range
        for (let i = start; i <= end; i++) {
          courts.push(i.toString());
        }
      } else {
        // Invalid range, just add as is
        courts.push(segment);
      }
    } 
    // Check if segment is a multi-digit number that should be split (like "123")
    else if (segment.length > 1 && /^[1-9]+$/.test(segment)) {
      // Split into individual digits
      segment.split('').forEach(digit => courts.push(digit));
    }
    else {
      // Regular number, add as is
      courts.push(segment);
    }
  });
  
  // Return unique courts with "Ct" prefix
  return [...new Set(courts.map(c => `Ct${c}`))];
}

// Helper function to format courts compactly for display
function compactCourtsDisplay(courts) {
  if (courts.length <= 1) return courts.join(', ');
  
  // Extract court numbers for processing
  const numbers = courts.map(court => {
    const match = court.match(/(\d+)/);
    return match ? parseInt(match[1]) : null;
  }).filter(num => num !== null);
  
  if (numbers.length !== courts.length) {
    // Not all courts have numbers, just join them as is
    return courts.join(', ');
  }
  
  // Sort numbers
  numbers.sort((a, b) => a - b);
  
  // Find ranges
  const ranges = [];
  let rangeStart = numbers[0];
  let rangeEnd = numbers[0];
  
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i] === rangeEnd + 1) {
      // Continue the range
      rangeEnd = numbers[i];
    } else {
      // End the current range and start a new one
      if (rangeStart === rangeEnd) {
        ranges.push(`Ct${rangeStart}`);
      } else {
        ranges.push(`Ct${rangeStart}-${rangeEnd}`);
      }
      rangeStart = rangeEnd = numbers[i];
    }
  }
  
  // Add the last range
  if (rangeStart === rangeEnd) {
    ranges.push(`Ct${rangeStart}`);
  } else {
    ranges.push(`Ct${rangeStart}-${rangeEnd}`);
  }
  
  return ranges.join(', ');
}

// Helper function to clean and standardize a single time with context
function cleanSingleTime(timeStr, contextPeriod = null) {
  if (!timeStr) return '';
  
  console.log('cleanSingleTime input:', timeStr, 'context:', contextPeriod);
  
  // First, check if there's an explicit AM/PM in the input
  const explicitPeriodMatch = timeStr.match(/([AP]M)/i);
  let explicitPeriod = explicitPeriodMatch ? explicitPeriodMatch[1].toUpperCase() : null;
  
  console.log('Explicit period found:', explicitPeriod);
  
  // Remove all non-time characters except numbers and colon
  const cleanedTime = timeStr.replace(/[^0-9:]/g, '');
  
  console.log('After cleaning time part:', cleanedTime);
  
  if (!cleanedTime) return '';
  
  // Ensure minutes exist
  let timePart = cleanedTime;
  if (!timePart.includes(':')) {
    timePart = timePart + ':00';
  }
  
  // Parse hours and minutes
  const timeParts = timePart.split(':');
  if (timeParts.length < 2) return '';
  
  let hours = parseInt(timeParts[0]);
  let minutes = parseInt(timeParts[1]);
  
  console.log('Parsed hours:', hours, 'minutes:', minutes);
  
  // Validate hours and minutes are reasonable numbers
  if (isNaN(hours) || isNaN(minutes)) return '';
  if (hours < 0 || hours > 23) return '';
  if (minutes < 0 || minutes > 59) return '';
  
  // Determine the period to use (explicit takes priority over context)
  let period;
  if (explicitPeriod) {
    console.log('Using explicit period:', explicitPeriod);
    period = explicitPeriod;
  } else if (contextPeriod) {
    console.log('Using context period:', contextPeriod);
    period = contextPeriod;
  } else {
    // Only guess period if none exists and no context
    console.log('No period found, guessing based on hour...');
    
    // Tennis court specific logic: consider both the hour and common patterns
    if (hours === 10) {
      // Special case: 10:30 is typically a morning class (10:30 AM)
      period = 'AM';
    }
    else if (hours >= 9 && hours <= 11) {
      // 9-11 are typically morning classes
      period = 'AM';
    }
    else if (hours >= 1 && hours <= 6) {
      // 1-6 are typically afternoon/evening classes  
      period = 'PM';
    }
    else if (hours === 7 || hours === 8) {
      // 7-8 are ambiguous, but more commonly evening classes in tennis courts
      period = 'PM';
    }
    // For times 12, assume PM (noon/midnight context will be determined by other factors)
    else if (hours === 12) {
      period = 'PM';
    }
    // For times 0, assume AM (midnight)
    else if (hours === 0) {
      period = 'AM';
    }
    // For other cases, assume AM
    else {
      period = 'AM';
    }
  }
  
  console.log('Final period:', period);
  
  // Ensure we're working with valid 12-hour format
  if (hours > 12) {
    // This shouldn't happen with proper input, but handle it
    hours = hours - 12;
    period = 'PM';
  }
  if (hours === 0) {
    hours = 12;
    period = 'AM';
  }
  
  // Format minutes
  minutes = minutes.toString().padStart(2, '0');
  
  const result = `${hours}:${minutes}${period}`;
  console.log('Final result:', result);
  
  return result;
}

// Helper function to convert 24-hour time to 12-hour format with period
function format24to12Hour(hour24) {
  let period = 'AM';
  let hour12 = hour24;
  
  if (hour24 >= 12) {
    period = 'PM';
    if (hour24 > 12) hour12 = hour24 - 12;
  }
  if (hour12 === 0) hour12 = 12;
  
  return { hour: hour12, period };
}

// Process a single time range (e.g. "1:30pm-3:30pm") with context
function processTimeRange(timeRange, contextPeriod = null) {
  if (!timeRange) return '';
  
  // Clean input and convert semicolons to colons first
  timeRange = timeRange.trim().replace(/;/g, ':');
  
  // Check if it's a time range with hyphen
  const parts = timeRange.split('-');
  
  // Process single time
  if (parts.length === 1) {
    const result = cleanSingleTime(parts[0], contextPeriod);
    if (result) {
      const periodMatch = result.match(/([AP]M)$/);
      const period = periodMatch ? periodMatch[1] : contextPeriod;
      return { result, period };
    }
    return '';
  }
  
  // Process time range
  if (parts.length === 2) {
    // Special handling: if the entire range ends with AM/PM (like "7-8:30pm"), 
    // that period should apply to the whole range
    const rangeEndPeriodMatch = timeRange.match(/([AP]M)\s*$/i);
    const rangeEndPeriod = rangeEndPeriodMatch ? rangeEndPeriodMatch[1].toUpperCase() : null;
    
    console.log(`Range "${timeRange}" - detected range period: ${rangeEndPeriod}`);
    
    // For start time: don't inherit period from end time, let it be determined by its own logic
    const hasStartExplicitPeriod = /[AP]M/i.test(parts[0]);
    let startContextPeriod = contextPeriod;
    // Removed automatic inheritance of end period for start time
    
    const startTime = cleanSingleTime(parts[0], startContextPeriod);
    
    // Extract period from start time to use as context for end time
    const startMatch = startTime.match(/([AP]M)$/);
    const startPeriod = startMatch ? startMatch[1] : contextPeriod;
    
    // For end time, only use start period as context if the end time doesn't have explicit period
    const hasEndExplicitPeriod = /[AP]M/i.test(parts[1]);
    let endContextPeriod = hasEndExplicitPeriod ? null : startPeriod;
    
    // Special case: if start time is 10:30AM and end time is 12:00, it should be 12:00PM (noon)
    if (startTime === '10:30AM' && parts[1].trim() === '12:00') {
      endContextPeriod = 'PM';
    }
    // More generally: if start is AM and end hour is 12, it should be PM (noon)
    else if (startPeriod === 'AM' && parts[1].trim().startsWith('12:')) {
      endContextPeriod = 'PM';
    }
    
    const endTime = cleanSingleTime(parts[1], endContextPeriod);
    
    if (!startTime || !endTime) return '';
    
    console.log('processTimeRange - start:', startTime, 'end:', endTime);
    
    // Parse times for range validation
    const startTimeMatch = startTime.match(/(\d+):(\d+)([AP]M)/);
    const endTimeMatch = endTime.match(/(\d+):(\d+)([AP]M)/);
    
    if (!startTimeMatch || !endTimeMatch) return '';
    
    const [, startHour, startMinutes, startTimePeriod] = startTimeMatch;
    const [, endHour, endMinutes, endTimePeriod] = endTimeMatch;
    
    // Convert to 24-hour for range calculation
    let startHour24 = parseInt(startHour);
    let endHour24 = parseInt(endHour);
    
    if (startTimePeriod === 'PM' && startHour24 !== 12) startHour24 += 12;
    if (endTimePeriod === 'PM' && endHour24 !== 12) endHour24 += 12;
    if (startTimePeriod === 'AM' && startHour24 === 12) startHour24 = 0;
    if (endTimePeriod === 'AM' && endHour24 === 12) endHour24 = 0;
    
    console.log('24-hour times - start:', startHour24, 'end:', endHour24);
    
    // Calculate range length
    let rangeLength = endHour24 - startHour24;
    if (rangeLength < 0) rangeLength += 24;
    
    console.log('Range length:', rangeLength, 'hours');
    
    // Only adjust if the range is clearly invalid (> 12 hours)
    if (rangeLength > 12) {
      console.log('Range too long, adjusting...');
      // Calculate new end time (2 hours after start for reasonable default)
      let newEndHour24 = startHour24 + 2;
      if (newEndHour24 >= 24) newEndHour24 -= 24;
      
      // Convert back to 12-hour format
      const { hour: newEndHour, period: newEndPeriod } = format24to12Hour(newEndHour24);
      
      // Keep original minutes
      const adjustedResult = `${startTime}-${newEndHour}:${endMinutes}${newEndPeriod}`;
      console.log('Adjusted result:', adjustedResult);
      return { result: adjustedResult, period: startTimePeriod };
    }
    
    const result = `${startTime}-${endTime}`;
    console.log('Normal result:', result);
    return { result, period: startTimePeriod };
  }
  
  return '';
}

// Main time processing function for multiple time ranges
function processTime(timeStr) {
  if (!timeStr) return '';
  
  // Clean the input: remove trailing commas and extra whitespace
  timeStr = timeStr.replace(/,\s*$/, '').trim();
  
  // Split by commas, semicolons, OR ampersands for multiple time ranges
  // We'll use a regex to properly split by commas, semicolons, or ampersands that aren't part of time values
  const timeRanges = timeStr.split(/[,;&]\s*/).filter(range => range.trim());
  
  // Process each time range independently first to check for explicit periods
  const processedRanges = [];
  let contextPeriod = null;
  
  for (const range of timeRanges) {
    // Check if this range has explicit AM/PM - if so, don't use context
    const hasExplicitPeriod = /[AP]M/i.test(range);
    const useContext = !hasExplicitPeriod ? contextPeriod : null;
    
    console.log(`Processing range: "${range}", hasExplicit: ${hasExplicitPeriod}, useContext: ${useContext}`);
    
    const processed = processTimeRange(range.trim(), useContext);
    
    if (processed) {
      // Handle both string and object returns
      if (typeof processed === 'string') {
        processedRanges.push(processed);
        // Extract period for context - update only if we found a period
        const periodMatch = processed.match(/([AP]M)/);
        if (periodMatch) {
          contextPeriod = periodMatch[1];
        }
      } else if (processed.result) {
        processedRanges.push(processed.result);
        // Use the period from the processed result
        if (processed.period) {
          contextPeriod = processed.period;
        }
      }
    }
  }
  
  // Join back with commas
  return processedRanges.join(', ');
}

// Helper function to parse time string into hours (for plotting)
function parseTimeToHours(timeStr) {
  if (!timeStr) return null;
  
  // Clean the time string and handle various formats
  timeStr = timeStr.trim();
  
  // Try to match the standard format first: "7:00PM", "12:30AM", etc.
  const match = timeStr.match(/(\d+):(\d+)([AP]M)/i);
  if (!match) {
    console.log(`Failed to parse time: "${timeStr}"`);
    return null;
  }
  
  let [, hours, minutes, period] = match;
  hours = parseInt(hours);
  minutes = parseInt(minutes);
  period = period.toUpperCase();
  
  // Convert to 24-hour format
  if (period === 'PM' && hours !== 12) hours += 12;
  if (period === 'AM' && hours === 12) hours = 0;
  
  // Return as decimal hours
  const result = hours + (minutes / 60);
  return result;
}

// Extract time ranges for plotting
function extractTimeRanges(timeStr) {
  if (!timeStr) return [];
  
  // Clean the input: remove trailing commas and extra whitespace
  timeStr = timeStr.replace(/,\s*$/, '').trim();
  
  const ranges = [];
  const timeRanges = timeStr.split(/[,;&]\s*/).filter(range => range.trim());
  
  for (const range of timeRanges) {
    // Check if it's a range (contains dash) or single time
    if (range.includes('-')) {
      const parts = range.split('-');
      if (parts.length === 2) {
        const startStr = parts[0].trim();
        const endStr = parts[1].trim();
        
        const start = parseTimeToHours(startStr);
        const end = parseTimeToHours(endStr);
        
        if (start !== null && end !== null) {
          ranges.push({ start, end });
        }
      }
    } else {
      // Single time - create a 1-hour block for visualization
      const singleTime = parseTimeToHours(range.trim());
      if (singleTime !== null) {
        ranges.push({ start: singleTime, end: singleTime + 1 });
      }
    }
  }
  
  return ranges;
}

// Helper function to get week number
function getWeekNumber(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

async function fetchAndRenderTable() {
  const expectedDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const weekdayOrder = {"Monday":1,"Tuesday":2,"Wednesday":3,"Thursday":4,"Friday":5,"Saturday":6,"Sunday":7};

  const tabs = document.getElementById("tab-buttons");
  const container = document.getElementById("table-container");
  const originalTable = document.getElementById("original-table");
  // removed toggleBtn because link now directly opens external

  try {
    const response = await fetch(csvUrl);
    const csvText = await response.text();

    // Parse CSV properly using a more robust approach
    const parseCSV = (csv) => {
      const lines = csv.trim().split(/\r?\n/);
      return lines.map(line => {
        // Split by comma but respect quotes
        const result = [];
        let cell = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            result.push(cell.trim());
            cell = '';
          } else {
            cell += char;
          }
        }
        
        // Add the last cell
        result.push(cell.trim());
        return result;
      });
    };

    const rows = parseCSV(csvText);
    let rawData = [];

    let lastDay = "";
    let lastDate = "";
    let currentCourt = "";

    // First pass: collect raw data
    for (let row of rows) {
      // Ensure we have enough columns
      if (row.length < 5) continue;
      
      // Extract values and trim
      let [V1, V2, V3, V4, V5, V6] = row.map(cell => cell ? cell.trim() : '');
      
      // Skip header row
      if (V1 === "Day of the Week") continue;

      // Identify location rows
      if (V1 && !V2 && !V3 && !V4 && !expectedDays.includes(V1)) {
        currentCourt = V1.replace(/ Park| School|Sunnyvale Middle School \(|\)/g, "").trim();
        continue;
      }

      // Fill in missing values from previous rows
      if (!V1) V1 = lastDay; else lastDay = V1;
      if (!V2) V2 = lastDate; else lastDate = V2;

      // Skip non-valid days and empty court numbers
      if (!expectedDays.includes(V1)) continue;
      if (!V4) continue;

      // Debug: Log the court column value
      console.log('Court column V4:', V4, 'from row:', [V1, V2, V3, V4, V5, V6]);

      // Process date format
      let d = V2;
      let parts = d.split("/");
      if (parts.length === 2) {
        d = `${parts[0]}/${parts[1]}/2025`;
      } else if (parts.length === 3 && parts[2].length === 2) {
        d = `${parts[0]}/${parts[1]}/20${parts[2]}`;
      }
      let dateObj = new Date(d);
      
      // For each court in this row, create a separate entry with the time(s) from this row only
      let courtNumbers = processCourt(V4);
      console.log('Processed court numbers:', courtNumbers, 'from V4:', V4);
      
      courtNumbers.forEach(court => {
        rawData.push({
          Day: V1,
          Date: d,
          DateObj: dateObj,
          RawTime: V3,
          Time: processTime(V3),
          RawCourt: V4,
          Court: court,
          Location: currentCourt
        });
      });
    }
    
    // Second pass: combine times for the same court on the same date/location only if they are from the same row
    // (in this case, there should be only one time per court per row, but we keep the logic for safety)
    let cleaned = [];
    const combinedData = {};
    rawData.forEach(item => {
      const key = `${item.Day}|${item.Date}|${item.Location}|${item.Court}|${item.Time}`;
      if (!combinedData[key]) {
        combinedData[key] = {
          ...item,
          Times: [item.Time]
        };
      } else {
        if (!combinedData[key].Times.includes(item.Time)) {
          combinedData[key].Times.push(item.Time);
        }
      }
    });
    // Convert back to array and set combined time string
    cleaned = Object.values(combinedData).map(item => ({
      ...item,
      Time: item.Times.join(', ')
    }));

    console.log('Processed data sample:', cleaned.slice(0, 10));

    // Sort by day, date, location, court
    cleaned.sort((a, b) => {
      if (weekdayOrder[a.Day] !== weekdayOrder[b.Day]) 
        return weekdayOrder[a.Day] - weekdayOrder[b.Day];
      if (b.DateObj - a.DateObj !== 0) 
        return b.DateObj - a.DateObj;
      if (a.Location !== b.Location) 
        return a.Location.localeCompare(b.Location);
        
      // Extract court numbers for numeric comparison
      const aNum = parseInt(a.Court.replace(/\D/g, '')) || 0;
      const bNum = parseInt(b.Court.replace(/\D/g, '')) || 0;
      return aNum - bNum;
    });

    // Debug: Log some sample data to see what we have
    console.log('Sample cleaned data after sorting:', cleaned.slice(0, 5).map(item => ({
      Day: item.Day,
      Date: item.Date,
      Location: item.Location,
      Court: item.Court,
      Time: item.Time
    })));

    // Group for display
    const grouped = {};
    cleaned.forEach(row => {
      if (!grouped[row.Day]) grouped[row.Day] = {};
      if (!grouped[row.Day][row.Date]) grouped[row.Day][row.Date] = [];
      grouped[row.Day][row.Date].push(row);
    });

    container.innerHTML = "";
    tabs.innerHTML = "";

    // Generate plot data for current data
    let allPlotData = {};
    
    for (const day of expectedDays) {
      if (grouped[day]) {
        const btn = document.createElement("button");
        btn.textContent = day;
        btn.onclick = () => switchTab(day);
        tabs.appendChild(btn);

        const section = document.createElement("div");
        section.id = `section-${day}`;
        section.className = "day-section";

        // Initialize plot data for this day
        allPlotData[day] = [];

        for (const date of Object.keys(grouped[day]).sort((a, b) => new Date(b) - new Date(a))) {
          const dateTitle = document.createElement("div");
          dateTitle.className = "date-title";
          dateTitle.textContent = date;
          section.appendChild(dateTitle);

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");

          ["Location", "Courts", "Time"].forEach(header => {
            const th = document.createElement("th");
            th.textContent = header;
            headRow.appendChild(th);
          });

          thead.appendChild(headRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          
          // Group by location and time
          const locationTimeGroups = {};
          
          // Sort entries by location and court number
          grouped[day][date].sort((a, b) => {
            if (a.Location !== b.Location) return a.Location.localeCompare(b.Location);
            const aNum = parseInt(a.Court.replace(/\D/g, '')) || 0;
            const bNum = parseInt(b.Court.replace(/\D/g, '')) || 0;
            return aNum - bNum;
          }).forEach(row => {
            // Use the original row data to preserve court groupings from the same row
            const key = `${row.Location}|${row.Time}|${row.RawCourt}`;
            
            // Debug: Log what we're processing
            console.log('Processing row:', { location: row.Location, court: row.Court, time: row.Time, rawCourt: row.RawCourt, key: key });
            
            if (!locationTimeGroups[key]) {
              locationTimeGroups[key] = {
                location: row.Location,
                time: row.Time,
                courts: [row.Court],
                rawCourt: row.RawCourt
              };
            } else {
              // Add court if not already included
              if (!locationTimeGroups[key].courts.includes(row.Court)) {
                locationTimeGroups[key].courts.push(row.Court);
              }
            }
          });
          
          // Debug: Log the grouped data
          console.log('Location time groups for', date, ':', locationTimeGroups);
          
          // Sort by location
          Object.values(locationTimeGroups)
            .sort((a, b) => a.location.localeCompare(b.location))
            .forEach(group => {
              const tr = document.createElement("tr");
              
              // Sort and format the courts for display
              const sortedCourts = group.courts.sort((a, b) => {
                const aNum = parseInt(a.replace(/\D/g, '')) || 0;
                const bNum = parseInt(b.replace(/\D/g, '')) || 0;
                return aNum - bNum;
              });
              
              // Format courts compactly when possible
              const formattedCourts = compactCourtsDisplay(sortedCourts);
              
              [group.location, formattedCourts, group.time].forEach(cell => {
                const td = document.createElement("td");
                td.textContent = cell;
                tr.appendChild(td);
              });
              
              tbody.appendChild(tr);
              
              // Separate each court to own entry for plot visualization
              const timeRanges = extractTimeRanges(group.time);
              group.courts.forEach(court => {
                timeRanges.forEach(range => {
                  if (!allPlotData[day]) allPlotData[day] = [];
                  
                  // Add one data point per court per time range
                  allPlotData[day].push({
                    location: group.location,
                    court: court,
                    date: date,
                    startTime: range.start,
                    endTime: range.end
                  });
                });
              });
            });
          
          table.appendChild(tbody);
          section.appendChild(table);
        }

        container.appendChild(section);
      }
    }

    // build original data table
    const tableOrig = document.createElement("table");
    const theadOrig = document.createElement("thead");
    const headRowOrig = document.createElement("tr");
    ["Day", "Date", "Time", "Court", "Location"].forEach(header => {
      const th = document.createElement("th");
      th.textContent = header;
      headRowOrig.appendChild(th);
    });
    theadOrig.appendChild(headRowOrig);
    tableOrig.appendChild(theadOrig);
    const tbodyOrig = document.createElement("tbody");
    cleaned.forEach(row => {
      const tr = document.createElement("tr");
      [row.Day, row.Date, row.Time, row.Court, row.Location].forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        tr.appendChild(td);
      });
      tbodyOrig.appendChild(tr);
    });
    tableOrig.appendChild(tbodyOrig);
    originalTable.appendChild(tableOrig);

    let currentTab = "";
    
    // Create plot for schedule visualization
    function createPlot(day, forCopy = false) {
      if (!day) return;
      
      const plotContainer = document.getElementById('plot-container');
      const legendContainer = document.getElementById('location-legend');
      const canvas = document.getElementById('schedule-plot');
      const ctx = canvas.getContext('2d');
      
      // Clear any existing content
      legendContainer.innerHTML = '';
      
      // Use the original cleaned data instead of parsing the table
      // Get the original data from the hidden table
      const originalTable = document.getElementById('original-table');
      const rows = Array.from(originalTable.querySelectorAll('tbody tr'));
      
      // Filter rows for current day
      const dayData = rows.filter(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        return cells[0]?.textContent.trim() === day;
      });
      
      console.log(`Found ${dayData.length} rows for ${day}`);
      
      // Group by location and court
      const courts = new Map();
      
      dayData.forEach(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        if (cells.length < 5) return;
        
        const location = cells[4].textContent.trim();
        const court = cells[3].textContent.trim();
        const time = cells[2].textContent.trim();
        
        // Skip entries with no time data - but log them for debugging
        if (!time || time.trim() === '') {
          console.log(`Skipping court ${court} at ${location} due to empty time data`);
          return;
        }
        
        const courtId = `${location}-${court}`;
        
        // Store the court if it's not already in our map
        if (!courts.has(courtId)) {
          courts.set(courtId, {
            id: courtId,
            location: location,
            court: court,
            label: `${location} - ${court}`,
            timeRanges: []
          });
        }
        
        // Parse time ranges from the original time data
        const timeRanges = extractTimeRanges(time);
        
        // Debug: Show individual time parsing for failed cases
        if (timeRanges.length === 0 && time && time.trim() !== '') {
          console.warn(`Failed to parse time ranges for court ${court} at ${location}: "${time}"`);
        }
        
        // Add all time ranges for this court
        timeRanges.forEach(range => {
          courts.get(courtId).timeRanges.push({
            startTime: range.start,
            endTime: range.end
          });
        });
      });
      
      console.log(`Total courts found: ${courts.size}`);
      console.log('Courts data:', Array.from(courts.values()));
      
      // Convert to array and sort by location and court number
      const sortedCourts = Array.from(courts.values()).sort((a, b) => {
        if (a.location !== b.location) {
          return a.location.localeCompare(b.location);
        }
        
        // Extract and compare court numbers
        const aMatch = a.court.match(/(\d+)/);
        const bMatch = b.court.match(/(\d+)/);
        const aNum = aMatch ? parseInt(aMatch[1]) : 0;
        const bNum = bMatch ? parseInt(bMatch[1]) : 0;
        return aNum - bNum;
      });
      
      // Generate color map for locations
      const locations = [...new Set(sortedCourts.map(c => c.location))];
      const colorPalette = [
        '#2563eb', '#dc2626', '#059669', '#7c3aed', '#ea580c', 
        '#0284c7', '#9333ea', '#0891b2', '#ca8a04', '#be185d',
        '#4338ca', '#15803d', '#b91c1c', '#4f46e5', '#0f766e'
      ];
      
      const colorMap = {};
      locations.forEach((loc, i) => {
        colorMap[loc] = colorPalette[i % colorPalette.length];
      });
      
      // Create legend only for copy version
      if (forCopy) {
        const legendTitle = document.createElement('div');
        legendTitle.className = 'axis-title';
        legendTitle.textContent = 'Court Locations';
        legendContainer.appendChild(legendTitle);
        
        locations.forEach(location => {
          const legendItem = document.createElement('div');
          legendItem.className = 'legend-item';
          
          const colorBox = document.createElement('div');
          colorBox.className = 'legend-color';
          colorBox.style.backgroundColor = colorMap[location];
          
          const label = document.createElement('span');
          label.textContent = location;
          
          legendItem.appendChild(colorBox);
          legendItem.appendChild(label);
          legendContainer.appendChild(legendItem);
        });
      }
      
      // Set canvas size based on whether it's for copy or display
      let padding, canvasWidth, canvasHeight, rowHeight, pixelRatio;
      const isMobile = window.innerWidth <= 768;
      
      if (forCopy) {
        // High resolution version for downloading
        padding = { top: 50, right: 30, bottom: 40, left: 200 };
        canvasWidth = Math.max(1400, plotContainer.clientWidth * 2);
        rowHeight = 45;
        
        if (isMobile) {
          padding.left = 120;
          padding.right = 20;
          padding.top = 35;
          padding.bottom = 25;
          rowHeight = 35;
        }
        
        const calculatedHeight = sortedCourts.length * rowHeight + padding.top + padding.bottom;
        canvasHeight = Math.max(calculatedHeight, 800);
        pixelRatio = 2; // High resolution for export
      } else {
        // Interactive display version - fit to container
        const containerRect = plotContainer.getBoundingClientRect();
        const availableWidth = containerRect.width - 30;
        const availableHeight = containerRect.height - 100; // Leave space for legend and controls
        
        padding = { top: 40, right: 20, bottom: 30, left: 180 };
        canvasWidth = availableWidth;
        
        // Calculate optimal row height based on available space
        const maxRowHeight = isMobile ? 30 : 40;
        const minRowHeight = isMobile ? 20 : 25;
        rowHeight = Math.max(minRowHeight, Math.min(maxRowHeight, (availableHeight - padding.top - padding.bottom) / sortedCourts.length));
        
        if (isMobile) {
          padding.left = 100;
          padding.right = 15;
          padding.top = 25;
          padding.bottom = 20;
        }
        
        canvasHeight = Math.min(availableHeight, sortedCourts.length * rowHeight + padding.top + padding.bottom);
        pixelRatio = window.devicePixelRatio || 1;
      }
      
      canvas.width = canvasWidth * pixelRatio;
      canvas.height = canvasHeight * pixelRatio;
      canvas.style.width = `${canvasWidth}px`;
      canvas.style.height = `${canvasHeight}px`;
      ctx.scale(pixelRatio, pixelRatio);
      
      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Draw time axis
      const startHour = 6; // 6 AM
      const endHour = 23; // 11 PM
      const hourWidth = (canvasWidth - padding.left - padding.right) / (endHour - startHour);
      
      // Draw time labels
      ctx.fillStyle = '#333';
      ctx.font = isMobile ? 'bold 10px Arial' : (forCopy ? 'bold 14px Arial' : 'bold 12px Arial');
      ctx.textAlign = 'center';
      
      // Draw both top and bottom time axes
      const drawTimeAxis = (yPosition, isTop) => {
        for (let hour = startHour; hour <= endHour; hour++) {
          const x = padding.left + (hour - startHour) * hourWidth;
          const displayHour = hour <= 12 ? hour : hour - 12;
          const ampm = hour < 12 ? 'AM' : 'PM';
          
          // Show time labels based on screen space
          const showLabel = isMobile ? (hour % 2 === 0 || hour === startHour || hour === endHour) : true;
          if (showLabel) {
            ctx.fillText(`${displayHour} ${ampm}`, x, yPosition);
          }
          
          // Draw vertical grid line, dotted at 4 PM and 8 PM
          ctx.beginPath();
          if (hour === 16 || hour === 20) {
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
          } else {
            ctx.setLineDash([]);
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
          }
          
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, canvasHeight - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw horizontal axis line
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;
        const lineOffset = isTop ? 15 : -15;
        ctx.moveTo(padding.left, yPosition + lineOffset);
        ctx.lineTo(canvasWidth - padding.right, yPosition + lineOffset);
        ctx.stroke();
        ctx.lineWidth = 1;
      };
      
      drawTimeAxis(canvasHeight - 10, false);
      drawTimeAxis(padding.top / 2, true);
      
      // Draw court names and time bars
      sortedCourts.forEach((court, index) => {
        const y = padding.top + index * rowHeight + rowHeight / 2;
        
        // Draw court label
        ctx.fillStyle = '#333';
        ctx.font = isMobile ? '9px Arial' : (forCopy ? '14px Arial' : '11px Arial');
        ctx.textAlign = 'right';
        
        // Abbreviate court label for mobile or non-copy version
        let displayLabel = court.label;
        if (isMobile || !forCopy) {
          displayLabel = displayLabel.replace('Fremont High School', 'Fremont');
          displayLabel = displayLabel.replace('Washington Park', 'Wash');
          displayLabel = displayLabel.replace('Ponderosa Park', 'Pond');
          displayLabel = displayLabel.replace('Sunnyvale Middle School', 'SMS');
          displayLabel = displayLabel.replace('Lakewood Park', 'Lakewood');
          displayLabel = displayLabel.replace('Serra Park', 'Serra');
          displayLabel = displayLabel.replace('Fairwood Park', 'Fairwood');
          displayLabel = displayLabel.replace('Ortega Park', 'Ortega');
          displayLabel = displayLabel.replace('Raynor Park', 'Raynor');
          displayLabel = displayLabel.replace('De Anza Park', 'DeAnza');
          displayLabel = displayLabel.replace('Sunnyvale Community Center', 'SCC');
          displayLabel = displayLabel.replace('Sunnyvale Tennis Center', 'STC');
          displayLabel = displayLabel.replace('Mango Park', 'Mango');
          displayLabel = displayLabel.replace('Location Mange', 'Mango');
        }
        
        ctx.fillText(displayLabel, padding.left - 5, y + 4);
        
        // Draw horizontal line for this court
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.beginPath();
        ctx.moveTo(padding.left, y + rowHeight / 2);
        ctx.lineTo(canvasWidth - padding.right, y + rowHeight / 2);
        ctx.stroke();
        
        // Draw time ranges for this court
        court.timeRanges.forEach(range => {
          const startX = padding.left + (range.startTime - startHour) * hourWidth;
          const endX = padding.left + (range.endTime - startHour) * hourWidth;
          const width = endX - startX;
          
          // Draw time bar
          ctx.fillStyle = colorMap[court.location];
          const barHeight = rowHeight - (forCopy ? 14 : 8);
          
          // Draw rounded rectangle
          const radius = barHeight / 2;
          const effectiveRadius = Math.min(radius, width / 2);
          
          ctx.beginPath();
          ctx.moveTo(startX + effectiveRadius, y - barHeight / 2);
          ctx.lineTo(endX - effectiveRadius, y - barHeight / 2);
          ctx.arcTo(endX, y - barHeight / 2, endX, y - barHeight / 2 + effectiveRadius, effectiveRadius);
          ctx.lineTo(endX, y + barHeight / 2 - effectiveRadius);
          ctx.arcTo(endX, y + barHeight / 2, endX - effectiveRadius, y + barHeight / 2, effectiveRadius);
          ctx.lineTo(startX + effectiveRadius, y + barHeight / 2);
          ctx.arcTo(startX, y + barHeight / 2, startX, y + barHeight / 2 - effectiveRadius, effectiveRadius);
          ctx.lineTo(startX, y - barHeight / 2 + effectiveRadius);
          ctx.arcTo(startX, y - barHeight / 2, startX + effectiveRadius, y - barHeight / 2, effectiveRadius);
          
          ctx.closePath();
          ctx.fill();
          
          // Draw border
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
          ctx.stroke();
        });
      });
      
      // Only add time axis title for copy version
      if (forCopy) {
        const timeAxisTitle = document.createElement('div');
        timeAxisTitle.className = 'axis-title';
        timeAxisTitle.textContent = '';
        legendContainer.appendChild(timeAxisTitle);
      }
    }

    function switchTab(day) {
      document.querySelectorAll('.day-section').forEach(sec => sec.classList.remove('active'));
      document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`section-${day}`).classList.add('active');
      Array.from(tabs.children).find(btn => btn.textContent === day).classList.add('active');
      currentTab = day;
      
      // Update the button text with abbreviation
      document.querySelector('.tab-buttons').setAttribute('data-day', day.substring(0, 3));
      
      // Check if we're in plot view
      const isPlotView = document.getElementById('plot-view-btn').classList.contains('active');
      
      // Set display based on current view
      if (isPlotView) {
        container.style.display = "none";
        document.getElementById('plot-container').style.display = "block";
        document.getElementById('copy-plot-button').style.display = "flex";
        createPlot(day, false); // Display version without legend
      } else {
        container.style.display = "block";
        document.getElementById('plot-container').style.display = "none";
        document.getElementById('copy-plot-button').style.display = "none";
      }
      
      originalTable.style.display = "none";
    }

    // Improved copy function for better formatting
    document.getElementById("copy-button").addEventListener("click", () => {
      if (!currentTab) return;
      
      // Get today's date for comparison
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Helper function to simplify location names
      function simplifyLocation(location) {
        return location
          .replace('Fremont High School', 'Fremont')
          .replace('Washington Park', 'Wash')
          .replace('Ponderosa Park', 'Pond')
          .replace('Sunnyvale Middle School', 'SMS')
          .replace('Lakewood Park', 'Lakewood')
          .replace('Serra Park', 'Serra')
          .replace('Fairwood Park', 'Fairwood')
          .replace('Ortega Park', 'Ortega')
          .replace('Raynor Park', 'Raynor')
          .replace('De Anza Park', 'DeAnza')
          .replace('Sunnyvale Community Center', 'SCC')
          .replace('Sunnyvale Tennis Center', 'STC')
          .replace('Mango Park', 'Mango')
          .replace('Location Mange', 'Mango');
      }
      
      // Helper function to normalize date format
      function normalizeDate(dateStr) {
        const parts = dateStr.split('/');
        const month = parseInt(parts[0]);
        const day = parseInt(parts[1]);
        const year = parts[2] ? parseInt(parts[2]) : new Date().getFullYear();
        return `${month}/${day}/${year}`;
      }
      
      // Get the original data from the hidden table
      const originalTable = document.getElementById('original-table');
      const rows = Array.from(originalTable.querySelectorAll('tbody tr'));
      
      // Filter rows for current day
      const dayData = rows.filter(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        return cells[0]?.textContent.trim() === currentTab;
      });
      
      // Group by normalized date
      const dateGroups = {};
      dayData.forEach(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        const date = normalizeDate(cells[1].textContent.trim());
        const location = cells[4].textContent.trim();
        const court = cells[3].textContent.trim();
        const time = cells[2].textContent.trim();
        
        // Skip entries with no time data
        if (!time || time.trim() === '') {
          return;
        }
        
        if (!dateGroups[date]) {
          dateGroups[date] = {};
        }
        if (!dateGroups[date][location]) {
          dateGroups[date][location] = [];
        }
        dateGroups[date][location].push({ court, time });
      });
      
      let todayData = '';
      let otherData = '';
      let todayDateDisplay = '';
      
      // Process each date group
      Object.entries(dateGroups).forEach(([date, locations]) => {
        // Parse date
        const dateParts = date.split('/');
        const month = parseInt(dateParts[0]);
        const day = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        
        const dateObj = new Date(year, month - 1, day);
        dateObj.setHours(0, 0, 0, 0);
        
        // Format date for display
        const dateDisplay = `${month}/${day}`;
        
        // Add date with parentheses if not today
        const isToday = dateObj.getTime() === today.getTime();
        const datePrefix = isToday ? '' : `(${dateDisplay})`;
        
        if (isToday) {
          todayDateDisplay = dateDisplay;
        }
        
        // Process each location
        const sortedLocations = Object.keys(locations).sort();
        let sectionText = '';
        
        sortedLocations.forEach((location, index) => {
          const locationData = locations[location];
          
          // Mango Park is now available - process normally
          // (removed special unavailable handling)
          
          // Group by time and filter out empty times
          const timeGroups = {};
          locationData.forEach(item => {
            // Skip items with no valid time
            if (!item.time || item.time.trim() === '') {
              return;
            }
            if (!timeGroups[item.time]) {
              timeGroups[item.time] = [];
            }
            timeGroups[item.time].push(item.court);
          });
          
          const timeEntries = Object.entries(timeGroups);
          
          // Skip locations with no valid time entries
          if (timeEntries.length === 0) {
            return;
          }
          
          const simpleLocation = simplifyLocation(location);
          
          if (timeEntries.length === 1) {
            const [time, courts] = timeEntries[0];
            sectionText += `${simpleLocation}${datePrefix}: ${courts.join(', ')}: ${time}\n`;
          } else {
            sectionText += `${simpleLocation}${datePrefix}:\n`;
            timeEntries.forEach(([time, courts]) => {
              sectionText += `  ${courts.join(', ')}: ${time}\n`;
            });
          }
          
          if (index < sortedLocations.length - 1) {
            sectionText += '\n';
          }
        });
        
        if (isToday) {
          todayData = sectionText;
        } else {
          otherData += sectionText;
        }
      });
      
      const text = `SNV LT æ•™ç»ƒå åœºä¿¡æ¯ ${currentTab} ${todayDateDisplay}\n${todayData}${otherData}`;
      
      navigator.clipboard.writeText(text).then(() => {
        document.getElementById("copy-toast").style.opacity = 1;
        setTimeout(() => { document.getElementById("copy-toast").style.opacity = 0; }, 1500);
      });
    });
    
    // Direct copy plot to clipboard
    document.getElementById("copy-plot-button").addEventListener("click", copyPlotToClipboard);
    


    
    // Create a mobile-friendly version of the plot optimized for narrow screens
    function createMobileFriendlyPlot(day) {
      if (!day) return;
      
      const plotContainer = document.getElementById('plot-container');
      const legendContainer = document.getElementById('location-legend');
      const canvas = document.getElementById('schedule-plot');
      const ctx = canvas.getContext('2d');
      
      // Clear any existing content
      legendContainer.innerHTML = '';
      
      // Get the original data from the hidden table
      const originalTable = document.getElementById('original-table');
      const rows = Array.from(originalTable.querySelectorAll('tbody tr'));
      
      // Filter rows for current day
      const dayData = rows.filter(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        return cells[0]?.textContent.trim() === day;
      });
      
      // Group by location and court
      const courts = new Map();
      
      dayData.forEach(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        if (cells.length < 5) return;
        
        const location = cells[4].textContent.trim();
        const court = cells[3].textContent.trim();
        const time = cells[2].textContent.trim();
        
        // Skip entries with no time data
        if (!time || time.trim() === '') {
          return;
        }
        
        const courtId = `${location}-${court}`;
        
        if (!courts.has(courtId)) {
          courts.set(courtId, {
            id: courtId,
            location: location,
            court: court,
            label: `${location} - ${court}`,
            timeRanges: []
          });
        }
        
        const timeRanges = extractTimeRanges(time);
        timeRanges.forEach(range => {
          courts.get(courtId).timeRanges.push({
            startTime: range.start,
            endTime: range.end
          });
        });
      });
      
      // Convert to array and sort
      const sortedCourts = Array.from(courts.values()).sort((a, b) => {
        if (a.location !== b.location) {
          return a.location.localeCompare(b.location);
        }
        const aMatch = a.court.match(/(\d+)/);
        const bMatch = b.court.match(/(\d+)/);
        const aNum = aMatch ? parseInt(aMatch[1]) : 0;
        const bNum = bMatch ? parseInt(bMatch[1]) : 0;
        return aNum - bNum;
      });
      
      // Generate modern color map for locations with gradient-like colors
      const locations = [...new Set(sortedCourts.map(c => c.location))];
      const colorPalette = [
        '#6366f1', '#f59e0b', '#10b981', '#ef4444', '#8b5cf6',
        '#06b6d4', '#f97316', '#84cc16', '#ec4899', '#14b8a6',
        '#3b82f6', '#fbbf24', '#22c55e', '#f87171', '#a855f7'
      ];
      
      const colorMap = {};
      locations.forEach((loc, i) => {
        colorMap[loc] = colorPalette[i % colorPalette.length];
      });
      
      // Mobile-optimized dimensions - compact and efficient
      const padding = { top: 40, right: 25, bottom: 60, left: 180 }; // Reduced padding
      const canvasWidth = 800; // Wider for better readability
      const rowHeight = 35; // Compact row height for efficiency
      const canvasHeight = sortedCourts.length * rowHeight + padding.top + padding.bottom + 40; // Compact spacing
      const pixelRatio = 2; // High resolution
      
      canvas.width = canvasWidth * pixelRatio;
      canvas.height = canvasHeight * pixelRatio;
      canvas.style.width = `${canvasWidth}px`;
      canvas.style.height = `${canvasHeight}px`;
      ctx.scale(pixelRatio, pixelRatio);
      
      // Clear canvas with modern gradient background
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      
      // Create subtle gradient background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvasHeight);
      gradient.addColorStop(0, '#fafafa');
      gradient.addColorStop(1, '#f8fafc');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Draw time axis - use same range as display version
      const startHour = 6; // Same as display version
      const endHour = 23; // Same as display version
      const hourWidth = (canvasWidth - padding.left - padding.right) / (endHour - startHour);
      
      // Draw time labels with modern styling
      ctx.fillStyle = '#374151';
      ctx.font = '600 12px system-ui, -apple-system, sans-serif';
      ctx.textAlign = 'center';
      
      const drawTimeAxis = (yPosition, isTop) => {
        for (let hour = startHour; hour <= endHour; hour++) {
          const x = padding.left + (hour - startHour) * hourWidth;
          const displayHour = hour <= 12 ? hour : hour - 12;
          const ampm = hour < 12 ? 'AM' : 'PM';
          
          // Show fewer time labels for mobile
          const showLabel = hour % 2 === 0 || hour === startHour || hour === endHour;
          if (showLabel) {
            ctx.fillText(`${displayHour}${ampm}`, x, yPosition);
          }
          
          // Draw modern vertical grid lines
          ctx.beginPath();
          if (hour === 16 || hour === 20) {
            ctx.setLineDash([2, 4]);
            ctx.strokeStyle = 'rgba(99, 102, 241, 0.3)';
            ctx.lineWidth = 1.5;
          } else {
            ctx.setLineDash([]);
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
            ctx.lineWidth = 1;
          }
          
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, canvasHeight - padding.bottom - 10);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Draw modern horizontal axis line
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(100, 116, 139, 0.4)';
        ctx.lineWidth = 2;
        const lineOffset = isTop ? 12 : -12;
        ctx.moveTo(padding.left, yPosition + lineOffset);
        ctx.lineTo(canvasWidth - padding.right, yPosition + lineOffset);
        ctx.stroke();
      };
      
      drawTimeAxis(canvasHeight - 45, false); // Adjusted for compact layout
      drawTimeAxis(padding.top / 2, true);
      
      // Draw court names and time bars
      sortedCourts.forEach((court, index) => {
        const y = padding.top + index * rowHeight + rowHeight / 2;
        
        // Draw court label with modern styling
        ctx.fillStyle = '#374151';
        ctx.font = '500 11px system-ui, -apple-system, sans-serif';
        ctx.textAlign = 'right';
        
        let displayLabel = court.label;
        // More aggressive abbreviations for mobile
        displayLabel = displayLabel.replace('Fremont High School', 'Fremont');
        displayLabel = displayLabel.replace('Washington Park', 'Wash');
        displayLabel = displayLabel.replace('Ponderosa Park', 'Pond');
        displayLabel = displayLabel.replace('Sunnyvale Middle School', 'SMS');
        displayLabel = displayLabel.replace('Lakewood Park', 'Lakewood');
        displayLabel = displayLabel.replace('Serra Park', 'Serra');
        displayLabel = displayLabel.replace('Fairwood Park', 'Fairwood');
        displayLabel = displayLabel.replace('Ortega Park', 'Ortega');
        displayLabel = displayLabel.replace('Raynor Park', 'Raynor');
        displayLabel = displayLabel.replace('De Anza Park', 'DeAnza');
        displayLabel = displayLabel.replace('Sunnyvale Community Center', 'SCC');
        displayLabel = displayLabel.replace('Sunnyvale Tennis Center', 'STC');
        displayLabel = displayLabel.replace('Mango Park', 'Mango');
        displayLabel = displayLabel.replace('Location Mange', 'Mango');
        
        ctx.fillText(displayLabel, padding.left - 5, y + 3);
        
        // Draw subtle horizontal separator line
        ctx.strokeStyle = 'rgba(226, 232, 240, 0.6)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.left, y + rowHeight / 2 - 3); // Adjusted for compact rows
        ctx.lineTo(canvasWidth - padding.right, y + rowHeight / 2 - 3);
        ctx.stroke();
        
        // Draw time ranges for this court
        court.timeRanges.forEach(range => {
          // Draw all ranges that overlap with our time window
          if (range.endTime > startHour && range.startTime < endHour) {
            const startX = padding.left + (range.startTime - startHour) * hourWidth;
            const endX = padding.left + (range.endTime - startHour) * hourWidth;
            const width = endX - startX;
            
            // Draw modern time bar with shadow
            const barHeight = rowHeight - 15; // Adjusted for compact rows
            const radius = Math.min(barHeight / 2, 6);
            const effectiveRadius = Math.min(radius, width / 2);
            
            // Add subtle shadow first
            ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetY = 2;
            
            // Draw rounded rectangle with modern styling
            ctx.fillStyle = colorMap[court.location];
            ctx.beginPath();
            ctx.moveTo(startX + effectiveRadius, y - barHeight / 2);
            ctx.lineTo(endX - effectiveRadius, y - barHeight / 2);
            ctx.arcTo(endX, y - barHeight / 2, endX, y - barHeight / 2 + effectiveRadius, effectiveRadius);
            ctx.lineTo(endX, y + barHeight / 2 - effectiveRadius);
            ctx.arcTo(endX, y + barHeight / 2, endX - effectiveRadius, y + barHeight / 2, effectiveRadius);
            ctx.lineTo(startX + effectiveRadius, y + barHeight / 2);
            ctx.arcTo(startX, y + barHeight / 2, startX, y + barHeight / 2 - effectiveRadius, effectiveRadius);
            ctx.lineTo(startX, y - barHeight / 2 + effectiveRadius);
            ctx.arcTo(startX, y - barHeight / 2, startX + effectiveRadius, y - barHeight / 2, effectiveRadius);
            
            ctx.closePath();
            ctx.fill();
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            // Draw subtle border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        });
      });
      
      // Add modern legend at the bottom with proper spacing
      const legendY = canvasHeight - 20;
      ctx.font = '500 10px system-ui, -apple-system, sans-serif';
      ctx.textAlign = 'left';
      
      let legendX = padding.left;
      locations.forEach((location, index) => {
        // Abbreviate location names for legend
        let shortLocation = location
          .replace('Fremont High School', 'Fremont')
          .replace('Washington Park', 'Wash')
          .replace('Ponderosa Park', 'Pond')
          .replace('Sunnyvale Middle School', 'SMS')
          .replace('Lakewood Park', 'Lakewood')
          .replace('Sunnyvale Community Center', 'SCC')
          .replace('Sunnyvale Tennis Center', 'STC')
          .replace('Mango Park', 'Mango');
        
        // Draw modern color indicator with rounded corners
        ctx.fillStyle = colorMap[location];
        ctx.beginPath();
        ctx.roundRect(legendX, legendY - 10, 10, 10, 2);
        ctx.fill();
        
        // Draw text with modern color
        ctx.fillStyle = '#374151';
        ctx.fillText(shortLocation, legendX + 15, legendY - 2);
        
        // Move to next position (wrap if needed)
        legendX += ctx.measureText(shortLocation).width + 30;
        if (legendX > canvasWidth - 100 && index < locations.length - 1) {
          legendX = padding.left;
          // For simplicity, just continue on same line for mobile
        }
      });
    }
    
    async function copyPlotToClipboard() {
      if (!currentTab) {
        alert("Please select a day and switch to plot view first");
        return;
      }
      
      const plotToast = document.getElementById("plot-toast");
      plotToast.textContent = "Copying to clipboard...";
      plotToast.style.opacity = 1;
      
      try {
        const canvas = document.getElementById('schedule-plot');
        
        // Create mobile-optimized version for clipboard
        createMobileFriendlyPlot(currentTab);
        
        setTimeout(async () => {
          try {
            // Convert canvas to blob
            canvas.toBlob(async (blob) => {
              if (blob) {
                try {
                  // Use the Clipboard API to copy the image
                  await navigator.clipboard.write([
                    new ClipboardItem({
                      'image/png': blob
                    })
                  ]);
                  
                  plotToast.textContent = "Plot copied to clipboard âœ…";
                  setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
                  
                  // Restore display version
                  createPlot(currentTab, false);
                } catch (clipboardError) {
                  console.error('Clipboard API failed:', clipboardError);
                  
                  // Fallback: try to copy as data URL (less reliable but worth trying)
                  try {
                    const dataURL = canvas.toDataURL('image/png');
                    await navigator.clipboard.writeText(dataURL);
                    plotToast.textContent = "Plot data copied (paste as image) âœ…";
                    setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
                  } catch (fallbackError) {
                    console.error('Fallback clipboard failed:', fallbackError);
                    plotToast.textContent = "Copy failed - try downloading instead âŒ";
                    setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
                  }
                  
                  // Restore display version
                  createPlot(currentTab, false);
                }
              } else {
                plotToast.textContent = "Failed to create image âŒ";
                setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
              }
            }, 'image/png', 1.0);
          } catch (error) {
            console.error('Error creating blob:', error);
            plotToast.textContent = "Copy failed âŒ";
            setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
          }
        }, 100);
      } catch (err) {
        console.error('Error copying plot:', err);
        plotToast.textContent = "Copy failed âŒ";
        setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
      }
    }
    

    
    // Toggle between table and plot views
    document.getElementById('table-view-btn').addEventListener('click', () => {
      document.getElementById('table-container').style.display = 'block';
      document.getElementById('plot-container').style.display = 'none';
      document.getElementById('table-view-btn').classList.add('active');
      document.getElementById('plot-view-btn').classList.remove('active');
      document.getElementById('copy-plot-button').style.display = 'none';
    });
    
    document.getElementById('plot-view-btn').addEventListener('click', () => {
      document.getElementById('table-container').style.display = 'none';
      document.getElementById('plot-container').style.display = 'block';
      document.getElementById('table-view-btn').classList.remove('active');
      document.getElementById('plot-view-btn').classList.add('active');
      document.getElementById('copy-plot-button').style.display = 'flex';
      
      if (currentTab) {
        createPlot(currentTab, false); // Display version without legend
      }
    });
    
    // Add window resize handler for responsive plot
    let resizeTimeout;
    window.addEventListener('resize', () => {
      // Debounce resize events
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        // Only recreate plot if we're currently viewing it
        const isPlotView = document.getElementById('plot-view-btn').classList.contains('active');
        if (isPlotView && currentTab) {
          createPlot(currentTab, false);
        }
      }, 250);
    });

    const today = new Date();
    const todayDay = expectedDays[today.getDay()];
    const defaultDay = grouped[todayDay] ? todayDay : expectedDays.find(day => grouped[day]);
    if (defaultDay) {
      switchTab(defaultDay);
      // Set the initial day text with abbreviation
      document.querySelector('.tab-buttons').setAttribute('data-day', defaultDay.substring(0, 3));
    }

  } catch (error) {
    console.error("Failed to fetch or render CSV:", error);
    document.getElementById("table-container").innerHTML = "Could not load schedule. Please check network or CSV URL.";
  }
}

// Time processing tests can be enabled for debugging by uncommenting below
// console.log('=== Time Processing Tests ===');
// console.log('Context test - Input: "4:15-7:15, 8:15-9:15"');
// console.log('Context test - Output:', processTime("4:15-7:15, 8:15-9:15"));
// console.log('Mixed periods test - Input: "8-10am, 5-6pm, 7-8:30pm"');
// console.log('Mixed periods test - Output:', processTime("8-10am, 5-6pm, 7-8:30pm"));
// console.log('=== End Tests ===');

fetchAndRenderTable();

// Add this to your existing JavaScript
document.addEventListener('DOMContentLoaded', function() {
    const tabButtons = document.querySelector('.tab-buttons');
    
    // Add click handler for the expand/collapse button
    tabButtons.addEventListener('click', function(e) {
        if (e.target === this || e.target === this.firstElementChild) {
            this.classList.toggle('expanded');
        }
    });
    
    // Close the menu when clicking outside
    document.addEventListener('click', function(e) {
        if (!tabButtons.contains(e.target)) {
            tabButtons.classList.remove('expanded');
        }
    });
});
</script>
<div id="copy-toast" class="copy-toast">Copied text âœ…</div>
<div id="plot-toast" class="copy-toast">Copied plot âœ…</div>
</body>
</html>