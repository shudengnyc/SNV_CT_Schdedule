<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SNV Lifetime Courts Schedule</title>
  <!-- Add Chart.js for plotting -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Add html2canvas for capturing plot as image -->
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
<style>
    body {
      font-family: 'Poppins', sans-serif;
      margin: 0;
      padding: 2rem;
      background: linear-gradient(135deg, #f0f4ff, #e0ecff);
      color: #333;
    }
    /* Mobile-friendly styles */
    @media (max-width: 768px) {
      body {
        padding: 0.5rem;
      }
      h1 {
        font-size: 1.4rem;
        text-align: center;
        margin: 0.5rem 0;
      }
    }
    .tab-buttons {
      position: fixed;
      bottom: 24px;
      left: 24px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: #6366f1;
      border-radius: 50%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: all 0.3s ease;
      max-height: 80vh;
      overflow-y: auto;
      width: 80px;
      height: 80px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    
    .tab-buttons.expanded {
      border-radius: 20px;
      width: auto;
      height: auto;
      padding: 10px;
      background: rgba(255, 255, 255, 0.9);
      -webkit-backdrop-filter: blur(5px);
      backdrop-filter: blur(5px);
    }
    
    .tab-buttons::before {
      content: attr(data-day);
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.2rem;
      color: white;
      cursor: pointer;
      z-index: 1001;
      font-weight: 600;
      text-align: center;
      width: 100%;
    }
    
    .tab-buttons.expanded::before {
      content: "âœ•";
      font-size: 1.2rem;
      left: 10px;
      transform: translateY(-50%);
      color: #333;
      width: auto;
    }
    
    /* Mobile tab buttons */
    @media (max-width: 768px) {
      .tab-buttons {
        bottom: 16px;
        left: 16px;
        width: 60px;
        height: 60px;
      }
      .tab-buttons::before {
        font-size: 1rem;
      }
    }
    
    .tab-buttons button {
      padding: 8px 15px;
      background: #c7d2fe;
      border: none;
      border-radius: 12px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
      opacity: 0;
      transform: translateX(-20px);
      pointer-events: none;
      margin-left: 25px;
      display: none;
    }
    
    .tab-buttons.expanded button {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
      display: block;
    }
    
    .tab-buttons button.active {
      background: #6366f1;
      color: white;
    }
    
    .tab-buttons button:hover {
      transform: scale(1.05);
      background: #4f46e5;
    }
    
    .tab-buttons button::after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }
    
    .tab-buttons:active::after {
      transform: scale(2);
      opacity: 1;
      transition: 0s;
    }
    
    .day-section {
      display: none;
      animation: fadeSlide 0.5s ease;
    }
    
    .day-section.active {
      display: block;
    }
    
    @keyframes fadeSlide {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .date-title {
      font-size: 1.6rem;
      color: #4f46e5;
      margin: 2rem 0 1rem;
      padding-left: 8px;
      border-left: 4px solid #6366f1;
    }
    /* Mobile date title */
    @media (max-width: 768px) {
      .date-title {
        font-size: 1.2rem;
        margin: 1rem 0 0.5rem;
      }
    }
    table {
      width: 100%;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      margin-bottom: 3rem;
      border-collapse: collapse;
      font-size: 1.2rem;
    }
    /* Responsive tables for mobile */
    @media (max-width: 768px) {
      table {
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
      }
    }
    th, td {
      padding: 14px;
      text-align: center;
    }
    @media (max-width: 768px) {
      th, td {
        padding: 8px 4px;
      }
    }
    th {
      background: #4f46e5;
      color: white;
      text-transform: uppercase;
    }
    tr:nth-child(even) td {
      background-color: #eef2ff;
    }
    .buttons-container {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    /* Adjust buttons for mobile */
    @media (max-width: 768px) {
      .buttons-container {
        bottom: 16px;
        right: 16px;
        gap: 12px;
      }
    }
    .action-button {
      width: 80px;
      height: 80px;
      background: #6366f1;
      color: white;
      border: none;
      border-radius: 50%;
      font-size: 2rem;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }
    @media (max-width: 768px) {
      .action-button {
        width: 60px;
        height: 60px;
        font-size: 1.5rem;
      }
    }
    .action-button:hover {
      transform: scale(1.05);
      background: #4f46e5;
    }
    .action-button::after {
      content: "";
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: rgba(255,255,255,0.4);
      border-radius: 50%;
      transform: scale(0);
      opacity: 0;
      transition: transform 0.4s, opacity 0.4s;
    }
    .action-button:active::after {
      transform: scale(2);
      opacity: 1;
      transition: 0s;
    }
    .copy-toast {
      position: fixed;
      bottom: 110px;
      right: 24px;
      background: rgba(79,70,229,0.9);
      color: white;
      padding: 12px 24px;
      border-radius: 30px;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.4s;
    }
    @media (max-width: 768px) {
      .copy-toast {
        bottom: 85px;
        right: 16px;
        padding: 8px 16px;
        font-size: 0.9rem;
      }
    }
    .plot-container {
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      margin-bottom: 3rem;
      height: auto;
      min-height: 700px;
      overflow-y: visible;
      overflow-x: auto;
    }
    /* Mobile-specific plot container adjustments */
    @media (max-width: 768px) {
      .plot-container {
        padding: 8px;
        min-height: 500px;
        margin-bottom: 1.5rem;
      }
    }
    .view-toggle {
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .view-toggle button {
      padding: 8px 16px;
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      cursor: pointer;
    }
    @media (max-width: 768px) {
      .view-toggle button {
        padding: 6px 12px;
        font-size: 0.9rem;
      }
    }
    .view-toggle button.active {
      background: #c7d2fe;
      font-weight: bold;
    }
    .view-toggle button:first-child {
      border-radius: 20px 0 0 20px;
    }
    .view-toggle button:last-child {
      border-radius: 0 20px 20px 0;
    }
    .location-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 0 auto 15px;
      justify-content: center;
      padding: 12px;
      background: #f8fafc;
      border-radius: 8px;
      max-width: 90%;
      border: 1px solid #e2e8f0;
    }
    @media (max-width: 768px) {
      .location-legend {
        padding: 8px;
        gap: 8px;
        margin-bottom: 10px;
      }
    }
    .legend-item {
      display: flex;
      align-items: center;
      font-size: 0.9rem;
      font-weight: 500;
      padding: 4px 8px;
      border-radius: 4px;
      background: #fff;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    @media (max-width: 768px) {
      .legend-item {
        font-size: 0.8rem;
        padding: 3px 6px;
      }
    }
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      margin-right: 6px;
    }
    @media (max-width: 768px) {
      .legend-color {
        width: 10px;
        height: 10px;
        margin-right: 4px;
      }
    }
    .axis-title {
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      color: #4f46e5;
      margin: 5px 0;
    }
    @media (max-width: 768px) {
      .axis-title {
        font-size: 0.9rem;
        margin: 3px 0;
      }
    }
    .week-indicator {
      font-weight: bold;
      margin-left: 4px;
      color: #ff5722;
    }
    /* Adjust plot size for mobile */
    @media (max-width: 768px) {
      #schedule-plot {
        max-width: 100%;
      }
    }
    /* Add this at the bottom to ensure it's applied */
    @media (max-width: 768px) {
      /* Fix horizontal scrolling issues on mobile */
      .plot-container::-webkit-scrollbar {
        height: 6px;
      }
      .plot-container::-webkit-scrollbar-thumb {
        background-color: rgba(99, 102, 241, 0.5);
        border-radius: 3px;
      }
      .plot-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.05);
      }
    }
  </style>
</head>
<body>
  <h1>SNV Lifetime Courts Schedule</h1>
  
  <div id="tab-buttons" class="tab-buttons"></div>
  
  <div class="view-toggle">
    <button id="table-view-btn" class="active">Table View</button>
    <button id="plot-view-btn">Schedule Plot</button>
  </div>
  
  <div id="table-container">Loading table...</div>
  <div id="plot-container" class="plot-container" style="display:none;">
    <div id="location-legend" class="location-legend"></div>
    <canvas id="schedule-plot"></canvas>
  </div>
  <div id="original-table" style="display:none;"></div>
<div style="text-align:center; margin: 2rem 0 0 0;">
  <a href="https://docs.google.com/spreadsheets/d/1zpnq9KvS73oZ8SK1JbUaBuK9u9nv_3NArXW1Hy7Pkzs/edit?gid=0#gid=0" target="_blank" rel="noopener" style="background:#4f46e5; color:white; padding:10px 20px; border:none; border-radius:20px; font-weight:600; cursor:pointer; text-decoration:none; display:inline-block;">Show Original Data</a>
</div>
  <div class="buttons-container">
    <button id="copy-button" class="action-button" title="Copy Current Tab">ðŸ“‹</button>
    <button id="copy-plot-button" class="action-button" title="Copy Plot as Image" style="display:none;">ðŸ“Š</button>
  </div>

<script>
const csvUrl = "https://corsproxy.io/?https://docs.google.com/spreadsheets/d/1zpnq9KvS73oZ8SK1JbUaBuK9u9nv_3NArXW1Hy7Pkzs/export?format=csv";

// Helper function to process court numbers
function processCourt(courtStr) {
  if (!courtStr) return '';
  
  // Remove any non-essential characters, preserving numbers, commas, and hyphens
  const cleaned = courtStr.replace(/[^0-9,\-]/g, '').trim();
  if (!cleaned) return 'Ct1'; // Default to court 1 if no valid data
  
  // Process the cleaned string to extract all court numbers
  const courts = [];
  
  // Split by commas first
  const segments = cleaned.split(',').map(s => s.trim()).filter(s => s);
  
  segments.forEach(segment => {
    // Check if segment contains a range (e.g., "1-5")
    if (segment.includes('-')) {
      const [start, end] = segment.split('-').map(n => parseInt(n.trim()));
      // Validate that we have valid start/end numbers
      if (!isNaN(start) && !isNaN(end) && start <= end) {
        // Generate all numbers in the range
        for (let i = start; i <= end; i++) {
          courts.push(i.toString());
        }
      } else {
        // Invalid range, just add as is
        courts.push(segment);
      }
    } 
    // Check if segment is a multi-digit number that should be split (like "123")
    else if (segment.length > 1 && /^[1-9]+$/.test(segment)) {
      // Split into individual digits
      segment.split('').forEach(digit => courts.push(digit));
    }
    else {
      // Regular number, add as is
      courts.push(segment);
    }
  });
  
  // Return unique courts with "Ct" prefix
  return courts.map(c => `Ct${c}`);
}

// Helper function to format courts compactly for display
function compactCourtsDisplay(courts) {
  if (courts.length <= 1) return courts.join(', ');
  
  // Extract court numbers for processing
  const numbers = courts.map(court => {
    const match = court.match(/(\d+)/);
    return match ? parseInt(match[1]) : null;
  }).filter(num => num !== null);
  
  if (numbers.length !== courts.length) {
    // Not all courts have numbers, just join them as is
    return courts.join(', ');
  }
  
  // Sort numbers
  numbers.sort((a, b) => a - b);
  
  // Find ranges
  const ranges = [];
  let rangeStart = numbers[0];
  let rangeEnd = numbers[0];
  
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i] === rangeEnd + 1) {
      // Continue the range
      rangeEnd = numbers[i];
    } else {
      // End the current range and start a new one
      if (rangeStart === rangeEnd) {
        ranges.push(`Ct${rangeStart}`);
      } else {
        ranges.push(`Ct${rangeStart}-${rangeEnd}`);
      }
      rangeStart = rangeEnd = numbers[i];
    }
  }
  
  // Add the last range
  if (rangeStart === rangeEnd) {
    ranges.push(`Ct${rangeStart}`);
  } else {
    ranges.push(`Ct${rangeStart}-${rangeEnd}`);
  }
  
  return ranges.join(', ');
}

// Helper function to clean and standardize a single time
function cleanSingleTime(timeStr) {
  if (!timeStr) return '';
  
  // Remove all non-time characters except numbers, colon, and AM/PM
  timeStr = timeStr.replace(/[^0-9:APMapm]/g, '');
  
  // Extract time components
  let [time, period] = timeStr.split(/([AP]M)/i);
  if (!time) return '';
  
  // Ensure minutes exist
  if (!time.includes(':')) {
    time = time + ':00';
  }
  
  // Parse hours and minutes
  let [hours, minutes] = time.split(':').map(num => parseInt(num));
  
  // Validate hours and minutes are reasonable numbers
  if (isNaN(hours) || isNaN(minutes)) return '';
  if (hours < 0 || hours > 23) return '';
  if (minutes < 0 || minutes > 59) return '';
  
  // Clean up period
  period = period ? period.toUpperCase() : '';
  
  // Convert to 24-hour for validation
  let hour24 = hours;
  if (period === 'PM' && hours !== 12) hour24 += 12;
  if (period === 'AM' && hours === 12) hour24 = 0;
  
  // If no period specified, assume AM for times before noon
  if (!period) {
    period = hour24 < 12 ? 'AM' : 'PM';
  }
  
  // Apply tennis court hours (7 AM - 11 PM)
  if (hour24 < 7) {
    // If before 7 AM, assume it should be PM
    hour24 += 12;
    period = 'PM';
  } else if (hour24 >= 23) {
    // If after 11 PM, assume it should be AM
    hour24 -= 12;
    period = 'AM';
  }
  
  // Convert back to 12-hour format
  hours = hour24 > 12 ? hour24 - 12 : hour24;
  if (hours === 0) hours = 12;
  
  // Format minutes
  minutes = minutes.toString().padStart(2, '0');
  
  return `${hours}:${minutes}${period}`;
}

// Helper function to convert 24-hour time to 12-hour format with period
function format24to12Hour(hour24) {
  let period = 'AM';
  let hour12 = hour24;
  
  if (hour24 >= 12) {
    period = 'PM';
    if (hour24 > 12) hour12 = hour24 - 12;
  }
  if (hour12 === 0) hour12 = 12;
  
  return { hour: hour12, period };
}

// Process a single time range (e.g. "1:30pm-3:30pm")
function processTimeRange(timeRange) {
  if (!timeRange) return '';
  
  // Clean input and convert semicolons to colons first
  timeRange = timeRange.trim().replace(/;/g, ':');
  
  // Check if it's a time range with hyphen
  const parts = timeRange.split('-');
  
  // Process single time
  if (parts.length === 1) {
    return cleanSingleTime(parts[0]);
  }
  
  // Process time range
  if (parts.length === 2) {
    const startTime = cleanSingleTime(parts[0]);
    const endTime = cleanSingleTime(parts[1]);
    
    if (!startTime || !endTime) return '';
    
    // Parse times for range validation
    const startMatch = startTime.match(/(\d+):(\d+)([AP]M)/);
    const endMatch = endTime.match(/(\d+):(\d+)([AP]M)/);
    
    if (!startMatch || !endMatch) return '';
    
    const [, startHour, startMinutes, startPeriod] = startMatch;
    const [, endHour, endMinutes, endPeriod] = endMatch;
    
    // Convert to 24-hour for range calculation
    let startHour24 = parseInt(startHour);
    let endHour24 = parseInt(endHour);
    
    if (startPeriod === 'PM' && startHour24 !== 12) startHour24 += 12;
    if (endPeriod === 'PM' && endHour24 !== 12) endHour24 += 12;
    if (startPeriod === 'AM' && startHour24 === 12) startHour24 = 0;
    if (endPeriod === 'AM' && endHour24 === 12) endHour24 = 0;
    
    // Calculate range length
    let rangeLength = endHour24 - startHour24;
    if (rangeLength < 0) rangeLength += 24;
    
    // If range is invalid (> 8 hours or end before start), adjust end time
    if (rangeLength > 8 || (startPeriod === endPeriod && endHour24 < startHour24)) {
      // Calculate new end time (4 hours after start)
      let newEndHour24 = startHour24 + 4;  // Changed from 8 to 4 hours
      if (newEndHour24 >= 24) newEndHour24 -= 24;
      
      // Convert back to 12-hour format
      const { hour: newEndHour, period: newEndPeriod } = format24to12Hour(newEndHour24);
      
      // Keep original minutes
      return `${startTime}-${newEndHour}:${endMinutes}${newEndPeriod}`;
    }
    
    return `${startTime}-${endTime}`;
  }
  
  return '';
}

// Main time processing function for multiple time ranges
function processTime(timeStr) {
  if (!timeStr) return '';
  
  // Split by commas for multiple time ranges
  // We'll use a regex to properly split by commas that aren't part of time values
  const timeRanges = timeStr.split(/,\s*/).filter(range => range.trim());
  
  // Process each time range and filter out empty results
  const processedRanges = timeRanges
    .map(range => processTimeRange(range.trim()))
    .filter(range => range);
  
  // Join back with commas
  return processedRanges.join(', ');
}

// Helper function to parse time string into hours (for plotting)
function parseTimeToHours(timeStr) {
  if (!timeStr) return null;
  
  const match = timeStr.match(/(\d+):(\d+)([AP]M)/);
  if (!match) return null;
  
  let [, hours, minutes, period] = match;
  hours = parseInt(hours);
  minutes = parseInt(minutes);
  
  // Convert to 24-hour format
  if (period === 'PM' && hours !== 12) hours += 12;
  if (period === 'AM' && hours === 12) hours = 0;
  
  // Return as decimal hours
  return hours + (minutes / 60);
}

// Extract time ranges for plotting
function extractTimeRanges(timeStr) {
  if (!timeStr) return [];
  
  const ranges = [];
  const timeRanges = timeStr.split(/,\s*/).filter(range => range.trim());
  
  for (const range of timeRanges) {
    const parts = range.split('-');
    if (parts.length === 2) {
      const start = parseTimeToHours(parts[0]);
      const end = parseTimeToHours(parts[1]);
      
      if (start !== null && end !== null) {
        ranges.push({ start, end });
      }
    }
  }
  
  return ranges;
}

// Helper function to get week number
function getWeekNumber(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 4 - (d.getDay() || 7));
  const yearStart = new Date(d.getFullYear(), 0, 1);
  return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
}

async function fetchAndRenderTable() {
  const expectedDays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  const weekdayOrder = {"Monday":1,"Tuesday":2,"Wednesday":3,"Thursday":4,"Friday":5,"Saturday":6,"Sunday":7};

  const tabs = document.getElementById("tab-buttons");
  const container = document.getElementById("table-container");
  const originalTable = document.getElementById("original-table");
  // removed toggleBtn because link now directly opens external

  try {
    const response = await fetch(csvUrl);
    const csvText = await response.text();

    // Parse CSV properly using a more robust approach
    const parseCSV = (csv) => {
      const lines = csv.trim().split(/\r?\n/);
      return lines.map(line => {
        // Split by comma but respect quotes
        const result = [];
        let cell = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            result.push(cell.trim());
            cell = '';
          } else {
            cell += char;
          }
        }
        
        // Add the last cell
        result.push(cell.trim());
        return result;
      });
    };
    
    const rows = parseCSV(csvText);
    let rawData = [];

    let lastDay = "";
    let lastDate = "";
    let currentCourt = "";

    // First pass: collect raw data
    for (let row of rows) {
      // Ensure we have enough columns
      if (row.length < 5) continue;
      
      // Extract values and trim
      let [V1, V2, V3, V4, V5, V6] = row.map(cell => cell ? cell.trim() : '');
      
      // Skip header row
      if (V1 === "Day of the Week") continue;

      // Identify location rows
      if (V1 && !V2 && !V3 && !V5 && !expectedDays.includes(V1)) {
        currentCourt = V1.replace(/ Park| School|Sunnyvale Middle School \(|\)/g, "").trim();
        continue;
      }

      // Fill in missing values from previous rows
      if (!V1) V1 = lastDay; else lastDay = V1;
      if (!V2) V2 = lastDate; else lastDate = V2;

      // Skip non-valid days and empty court numbers
      if (!expectedDays.includes(V1)) continue;
      if (!V5) continue;

      // Process date format
      let d = V2;
      let parts = d.split("/");
      if (parts.length === 2) {
        d = `${parts[0]}/${parts[1]}/2025`;
      } else if (parts.length === 3 && parts[2].length === 2) {
        d = `${parts[0]}/${parts[1]}/20${parts[2]}`;
      }
      let dateObj = new Date(d);
      
      // Add to raw data
      rawData.push({
        Day: V1,
        Date: d,
        DateObj: dateObj,
        RawTime: V3,
        Time: processTime(V3),
        RawCourt: V5,
        CourtNumbers: processCourt(V5),
        Location: currentCourt
      });
    }
    
    // Second pass: expand multi-court entries and process time ranges
    let cleaned = [];
    
    // Process each raw data entry
    rawData.forEach(entry => {
      // Get the processed court numbers (already an array)
      const courtNumbers = entry.CourtNumbers;
      
      // If it's an array with multiple courts
      if (Array.isArray(courtNumbers)) {
        // Create a separate record for each court
        courtNumbers.forEach(court => {
          if (court) {
            cleaned.push({
              Day: entry.Day,
              Date: entry.Date,
              DateObj: entry.DateObj,
              Time: entry.Time,
              Court: court,
              Location: entry.Location
            });
          }
        });
      } else {
        // Single court, add as is
        cleaned.push({
          Day: entry.Day,
          Date: entry.Date,
          DateObj: entry.DateObj,
          Time: entry.Time,
          Court: courtNumbers,
          Location: entry.Location
        });
      }
    });

    console.log('Processed data sample:', cleaned.slice(0, 10));

    // Sort by day, date, location, court
    cleaned.sort((a, b) => {
      if (weekdayOrder[a.Day] !== weekdayOrder[b.Day]) 
        return weekdayOrder[a.Day] - weekdayOrder[b.Day];
      if (b.DateObj - a.DateObj !== 0) 
        return b.DateObj - a.DateObj;
      if (a.Location !== b.Location) 
        return a.Location.localeCompare(b.Location);
        
      // Extract court numbers for numeric comparison
      const aNum = parseInt(a.Court.replace(/\D/g, '')) || 0;
      const bNum = parseInt(b.Court.replace(/\D/g, '')) || 0;
      return aNum - bNum;
    });

    // Third pass: Combine times for the same court on the same date
    const combinedData = {};
    
    cleaned.forEach(item => {
      const key = `${item.Day}|${item.Date}|${item.Location}|${item.Court}`;
      
      if (!combinedData[key]) {
        combinedData[key] = {
          ...item,
          Times: [item.Time]
        };
      } else {
        // Add time to existing entry if not already included
        if (!combinedData[key].Times.includes(item.Time)) {
          combinedData[key].Times.push(item.Time);
        }
      }
    });
    
    // Convert back to array and set combined time string
    const finalData = Object.values(combinedData).map(item => ({
      ...item,
      Time: item.Times.join(', ')
    }));
    
    // Debug the final dataset
    console.log('Final court data:', finalData.slice(0, 10).map(item => ({
      Day: item.Day,
      Date: item.Date,
      Location: item.Location,
      Court: item.Court,
      Time: item.Time
    })));

    // Group for display
    const grouped = {};
    finalData.forEach(row => {
      if (!grouped[row.Day]) grouped[row.Day] = {};
      if (!grouped[row.Day][row.Date]) grouped[row.Day][row.Date] = [];
      grouped[row.Day][row.Date].push(row);
    });

    container.innerHTML = "";
    tabs.innerHTML = "";

    // Generate plot data for current data
    let allPlotData = {};
    
    for (const day of expectedDays) {
      if (grouped[day]) {
        const btn = document.createElement("button");
        btn.textContent = day;
        btn.onclick = () => switchTab(day);
        tabs.appendChild(btn);

        const section = document.createElement("div");
        section.id = `section-${day}`;
        section.className = "day-section";

        // Initialize plot data for this day
        allPlotData[day] = [];

        for (const date of Object.keys(grouped[day]).sort((a, b) => new Date(b) - new Date(a))) {
          const dateTitle = document.createElement("div");
          dateTitle.className = "date-title";
          dateTitle.textContent = date;
          section.appendChild(dateTitle);

          const table = document.createElement("table");
          const thead = document.createElement("thead");
          const headRow = document.createElement("tr");

          ["Location", "Courts", "Time"].forEach(header => {
            const th = document.createElement("th");
            th.textContent = header;
            headRow.appendChild(th);
          });

          thead.appendChild(headRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          
          // Group by location and time
          const locationTimeGroups = {};
          
          // Sort entries by location and court number
          grouped[day][date].sort((a, b) => {
            if (a.Location !== b.Location) return a.Location.localeCompare(b.Location);
            const aNum = parseInt(a.Court.replace(/\D/g, '')) || 0;
            const bNum = parseInt(b.Court.replace(/\D/g, '')) || 0;
            return aNum - bNum;
          }).forEach(row => {
            const key = `${row.Location}|${row.Time}`;
            
            if (!locationTimeGroups[key]) {
              locationTimeGroups[key] = {
                location: row.Location,
                time: row.Time,
                courts: [row.Court]
              };
            } else {
              // Add court if not already included
              if (!locationTimeGroups[key].courts.includes(row.Court)) {
                locationTimeGroups[key].courts.push(row.Court);
              }
            }
          });
          
          // Sort by location
          Object.values(locationTimeGroups)
            .sort((a, b) => a.location.localeCompare(b.location))
            .forEach(group => {
              const tr = document.createElement("tr");
              
              // Sort and format the courts for display
              const sortedCourts = group.courts.sort((a, b) => {
                const aNum = parseInt(a.replace(/\D/g, '')) || 0;
                const bNum = parseInt(b.replace(/\D/g, '')) || 0;
                return aNum - bNum;
              });
              
              // Format courts compactly when possible
              const formattedCourts = compactCourtsDisplay(sortedCourts);
              
              [group.location, formattedCourts, group.time].forEach(cell => {
                const td = document.createElement("td");
                td.textContent = cell;
                tr.appendChild(td);
              });
              
              tbody.appendChild(tr);
              
              // Separate each court to own entry for plot visualization
              const timeRanges = extractTimeRanges(group.time);
              group.courts.forEach(court => {
                timeRanges.forEach(range => {
                  if (!allPlotData[day]) allPlotData[day] = [];
                  
                  // Add one data point per court per time range
                  allPlotData[day].push({
                    location: group.location,
                    court: court,
                    date: date,
                    startTime: range.start,
                    endTime: range.end
                  });
                });
              });
            });
          
          table.appendChild(tbody);
          section.appendChild(table);
        }

        container.appendChild(section);
      }
    }

    // build original data table
    const tableOrig = document.createElement("table");
    const theadOrig = document.createElement("thead");
    const headRowOrig = document.createElement("tr");
    ["Day", "Date", "Time", "Court", "Location"].forEach(header => {
      const th = document.createElement("th");
      th.textContent = header;
      headRowOrig.appendChild(th);
    });
    theadOrig.appendChild(headRowOrig);
    tableOrig.appendChild(theadOrig);
    const tbodyOrig = document.createElement("tbody");
    finalData.forEach(row => {
      const tr = document.createElement("tr");
      [row.Day, row.Date, row.Time, row.Court, row.Location].forEach(cell => {
        const td = document.createElement("td");
        td.textContent = cell;
        tr.appendChild(td);
      });
      tbodyOrig.appendChild(tr);
    });
    tableOrig.appendChild(tbodyOrig);
    originalTable.appendChild(tableOrig);

    let currentTab = "";
    
    // Create plot for schedule visualization
    function createPlot(day) {
      if (!day) return;
      
      const plotContainer = document.getElementById('plot-container');
      const legendContainer = document.getElementById('location-legend');
      const canvas = document.getElementById('schedule-plot');
      const ctx = canvas.getContext('2d');
      
      // Clear any existing content
      legendContainer.innerHTML = '';
      
      // Extract all visible schedule entries from the table
      const activeSection = document.getElementById(`section-${day}`);
      if (!activeSection) {
        console.error("Could not find section for day:", day);
        return;
      }
      
      // Get all court schedule data from the visible table
      const courtData = [];
      const courts = new Map();
      
      // Extract all dates and their tables
      const dateTitles = activeSection.querySelectorAll(".date-title");
      
      dateTitles.forEach(dateTitle => {
        const date = dateTitle.textContent.trim();
        
        // Get the table following this date title
        const table = dateTitle.nextElementSibling;
        if (!table || table.tagName !== "TABLE") return;
        
        // Get all rows in the table
        const rows = table.querySelectorAll("tbody tr");
        rows.forEach(row => {
          const cells = row.querySelectorAll("td");
          if (cells.length !== 3) return;
          
          const location = cells[0].textContent.trim();
          const courtsText = cells[1].textContent.trim();
          const timeText = cells[2].textContent.trim();
          
          // Parse individual courts
          const individualCourts = [];
          
          // Handle court ranges like "Ct1-3"
          if (courtsText.includes("-")) {
            const match = courtsText.match(/Ct(\d+)-(\d+)/);
            if (match) {
              const start = parseInt(match[1]);
              const end = parseInt(match[2]);
              for (let i = start; i <= end; i++) {
                individualCourts.push(`Ct${i}`);
              }
            } else {
              individualCourts.push(courtsText);
            }
          } else if (courtsText.includes(",")) {
            // Handle comma-separated courts
            courtsText.split(",").forEach(c => {
              individualCourts.push(c.trim());
            });
          } else {
            // Single court
            individualCourts.push(courtsText);
          }
          
          // Parse time ranges
          const timeRanges = extractTimeRanges(timeText);
          
          // Add data for each court and time range
          individualCourts.forEach(court => {
            const courtId = `${location}-${court}`;
            
            // Store the court if it's not already in our map
            if (!courts.has(courtId)) {
              courts.set(courtId, {
                id: courtId,
                location: location,
                court: court,
                label: `${location} - ${court}`,
                timeRanges: []
              });
            }
            
            // Add all time ranges for this court
            timeRanges.forEach(range => {
              courts.get(courtId).timeRanges.push({
                date: date,
                startTime: range.start,
                endTime: range.end
              });
            });
          });
        });
      });
      
      // Convert to array and sort by location and court number
      const sortedCourts = Array.from(courts.values()).sort((a, b) => {
        if (a.location !== b.location) {
          return a.location.localeCompare(b.location);
        }
        
        // Extract and compare court numbers
        const aMatch = a.court.match(/(\d+)/);
        const bMatch = b.court.match(/(\d+)/);
        const aNum = aMatch ? parseInt(aMatch[1]) : 0;
        const bNum = bMatch ? parseInt(bMatch[1]) : 0;
        return aNum - bNum;
      });
      
      // Generate color map for locations
      const locations = [...new Set(sortedCourts.map(c => c.location))];
      const colorPalette = [
        '#2563eb', '#dc2626', '#059669', '#7c3aed', '#ea580c', 
        '#0284c7', '#9333ea', '#0891b2', '#ca8a04', '#be185d',
        '#4338ca', '#15803d', '#b91c1c', '#4f46e5', '#0f766e'
      ];
      
      const colorMap = {};
      locations.forEach((loc, i) => {
        colorMap[loc] = colorPalette[i % colorPalette.length];
      });
      
      // Create legend
      const legendTitle = document.createElement('div');
      legendTitle.className = 'axis-title';
      legendTitle.textContent = 'Court Locations';
      legendContainer.appendChild(legendTitle);
      
      locations.forEach(location => {
        const legendItem = document.createElement('div');
        legendItem.className = 'legend-item';
        
        const colorBox = document.createElement('div');
        colorBox.className = 'legend-color';
        colorBox.style.backgroundColor = colorMap[location];
        
        const label = document.createElement('span');
        label.textContent = location;
        
        legendItem.appendChild(colorBox);
        legendItem.appendChild(label);
        legendContainer.appendChild(legendItem);
      });
      
      // Set canvas size
      const padding = { top: 40, right: 20, bottom: 20, left: 200 }; // Further reduced bottom padding
      const canvasWidth = Math.max(plotContainer.clientWidth - 30, 1200); // Minimum width for higher resolution
      const rowHeight = 40; // Increased row height

      // Check if we're on a mobile device
      const isMobile = window.innerWidth <= 768;

      // Adjust settings for mobile
      if (isMobile) {
        padding.left = 100; // Less space for labels on mobile
        padding.right = 10;
        padding.top = 30;
        padding.bottom = 15;
      }

      // Calculate the actual height needed based on the number of courts
      const calculatedHeight = sortedCourts.length * rowHeight + padding.top + padding.bottom;
      // Use a smaller minimum height to reduce empty space
      const canvasHeight = Math.max(calculatedHeight, 650);
      
      // Set canvas to higher resolution for better image quality
      const pixelRatio = window.devicePixelRatio || 2; // Use at least 2x resolution
      canvas.width = canvasWidth * pixelRatio;
      canvas.height = canvasHeight * pixelRatio;
      canvas.style.width = `${canvasWidth}px`;
      canvas.style.height = `${canvasHeight}px`;
      ctx.scale(pixelRatio, pixelRatio);
      
      // Clear canvas
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // Draw time axis
      const startHour = 6; // 6 AM
      const endHour = 23; // 11 PM
      const hourWidth = (canvasWidth - padding.left - padding.right) / (endHour - startHour);
      
      // Draw time labels on bottom
      ctx.fillStyle = '#333';
      // Smaller font on mobile
      ctx.font = isMobile ? 'bold 10px Arial' : 'bold 14px Arial';
      ctx.textAlign = 'center';
      
      // Draw both top and bottom time axes
      const drawTimeAxis = (yPosition, isTop) => {
        for (let hour = startHour; hour <= endHour; hour++) {
          const x = padding.left + (hour - startHour) * hourWidth;
          const displayHour = hour <= 12 ? hour : hour - 12;
          const ampm = hour < 12 ? 'AM' : 'PM';
          
          // Draw time label - for mobile, only show every other hour to avoid crowding
          if (!isMobile || hour % 2 === 0 || hour === startHour || hour === endHour) {
            ctx.fillText(`${displayHour} ${ampm}`, x, yPosition);
          }
          
          // Draw vertical grid line, dotted at 4 PM and 8 PM
          ctx.beginPath();
          if (hour === 16 || hour === 20) {
            ctx.setLineDash([4, 4]);           // Dotted style
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
          } else {
            ctx.setLineDash([]);               // Solid style
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
          }
          
          // Draw grid lines full height for all hours
          ctx.moveTo(x, padding.top);
          ctx.lineTo(x, canvasHeight - padding.bottom);
          ctx.stroke();
          ctx.setLineDash([]);                 // Reset dash style
        }
        
        // Draw horizontal axis line
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.lineWidth = 1;
        // Position the axis line closer to the labels
        const lineOffset = isTop ? 15 : -15;
        ctx.moveTo(padding.left, yPosition + lineOffset);
        ctx.lineTo(canvasWidth - padding.right, yPosition + lineOffset);
        ctx.stroke();
        ctx.lineWidth = 1;
      };
      
      // Draw time axes at top and bottom
      // Move bottom axis closer to the last row
      drawTimeAxis(canvasHeight - 10, false); // Position closer to bottom
      drawTimeAxis(padding.top / 2, true);
      
      // Draw court names and time bars
      sortedCourts.forEach((court, index) => {
        const y = padding.top + index * rowHeight + rowHeight / 2;
        
        // Draw court label
        ctx.fillStyle = '#333';
        ctx.font = isMobile ? '10px Arial' : '14px Arial'; // Smaller font on mobile
        ctx.textAlign = 'right';
        
        // For mobile, abbreviate the court label to save space
        let displayLabel = court.label;
        if (isMobile) {
          // Abbreviate location names to save space
          displayLabel = displayLabel.replace('Fremont High', 'FremontH');
          displayLabel = displayLabel.replace('Washington', 'Wash');
          displayLabel = displayLabel.replace('Ponderosa', 'Pond');
        }
        
        ctx.fillText(displayLabel, padding.left - 5, y + 4);
        
        // Draw horizontal line for this court
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.beginPath();
        ctx.moveTo(padding.left, y + rowHeight / 2);
        ctx.lineTo(canvasWidth - padding.right, y + rowHeight / 2);
        ctx.stroke();
        
        // Draw time ranges for this court
        court.timeRanges.forEach(range => {
          const startX = padding.left + (range.startTime - startHour) * hourWidth;
          const endX = padding.left + (range.endTime - startHour) * hourWidth;
          const width = endX - startX;
          
          // Draw time bar
          ctx.fillStyle = colorMap[court.location];
          const barHeight = rowHeight - 14; // Adjusted for larger row height
          
          // Draw rounded rectangle
          const radius = barHeight / 2; // Corner radius
          
          // Make sure the radius isn't too large for the width
          const effectiveRadius = Math.min(radius, width / 2);
          
          ctx.beginPath();
          // Top-left corner
          ctx.moveTo(startX + effectiveRadius, y - barHeight / 2);
          // Top-right corner (with arc)
          ctx.lineTo(endX - effectiveRadius, y - barHeight / 2);
          ctx.arcTo(endX, y - barHeight / 2, endX, y - barHeight / 2 + effectiveRadius, effectiveRadius);
          // Bottom-right corner (with arc)
          ctx.lineTo(endX, y + barHeight / 2 - effectiveRadius);
          ctx.arcTo(endX, y + barHeight / 2, endX - effectiveRadius, y + barHeight / 2, effectiveRadius);
          // Bottom-left corner (with arc)
          ctx.lineTo(startX + effectiveRadius, y + barHeight / 2);
          ctx.arcTo(startX, y + barHeight / 2, startX, y + barHeight / 2 - effectiveRadius, effectiveRadius);
          // Top-left corner (with arc)
          ctx.lineTo(startX, y - barHeight / 2 + effectiveRadius);
          ctx.arcTo(startX, y - barHeight / 2, startX + effectiveRadius, y - barHeight / 2, effectiveRadius);
          
          ctx.closePath();
          ctx.fill();
          
          // Draw border with rounded corners
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)'; // Darker border for better visibility
          ctx.stroke();
        });
      });
      
      // Draw time axis title
      const timeAxisTitle = document.createElement('div');
      timeAxisTitle.className = 'axis-title';
      timeAxisTitle.textContent = '';
      legendContainer.appendChild(timeAxisTitle);
    }

    function switchTab(day) {
      document.querySelectorAll('.day-section').forEach(sec => sec.classList.remove('active'));
      document.querySelectorAll('.tab-buttons button').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`section-${day}`).classList.add('active');
      Array.from(tabs.children).find(btn => btn.textContent === day).classList.add('active');
      currentTab = day;
      
      // Update the button text with abbreviation
      document.querySelector('.tab-buttons').setAttribute('data-day', day.substring(0, 3));
      
      // Check if we're in plot view
      const isPlotView = document.getElementById('plot-view-btn').classList.contains('active');
      
      // Set display based on current view
      if (isPlotView) {
        container.style.display = "none";
        document.getElementById('plot-container').style.display = "block";
        document.getElementById('copy-plot-button').style.display = "flex";
        createPlot(day);
      } else {
        container.style.display = "block";
        document.getElementById('plot-container').style.display = "none";
        document.getElementById('copy-plot-button').style.display = "none";
      }
      
      originalTable.style.display = "none";
    }

    // Improved copy function for better formatting
    document.getElementById("copy-button").addEventListener("click", () => {
      if (!currentTab) return;
      
      // Get today's date for comparison
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Helper function to simplify location names
      function simplifyLocation(location) {
        return location
          .replace('Fremont High School', 'Fremont')
          .replace('Washington Park', 'Wash')
          .replace('Ponderosa Park', 'Pond')
          .replace('Sunnyvale Middle School', 'SMS')
          .replace('Lakewood Park', 'Lakewood')
          .replace('Serra Park', 'Serra')
          .replace('Fairwood Park', 'Fairwood')
          .replace('Ortega Park', 'Ortega')
          .replace('Raynor Park', 'Raynor')
          .replace('De Anza Park', 'DeAnza')
          .replace('Sunnyvale Community Center', 'SCC')
          .replace('Sunnyvale Tennis Center', 'STC')
          .replace('Mango Park', 'Mango');
      }
      
      // Helper function to normalize date format
      function normalizeDate(dateStr) {
        const parts = dateStr.split('/');
        const month = parseInt(parts[0]);
        const day = parseInt(parts[1]);
        const year = parts[2] ? parseInt(parts[2]) : new Date().getFullYear();
        return `${month}/${day}/${year}`;
      }
      
      // Get the original data from the hidden table
      const originalTable = document.getElementById('original-table');
      const rows = Array.from(originalTable.querySelectorAll('tbody tr'));
      
      // Filter rows for current day
      const dayData = rows.filter(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        return cells[0]?.textContent.trim() === currentTab;
      });
      
      // Group by normalized date
      const dateGroups = {};
      dayData.forEach(row => {
        const cells = Array.from(row.querySelectorAll('td'));
        const date = normalizeDate(cells[1].textContent.trim());
        const location = cells[4].textContent.trim();
        const court = cells[3].textContent.trim();
        const time = cells[2].textContent.trim();
        
        if (!dateGroups[date]) {
          dateGroups[date] = {};
        }
        if (!dateGroups[date][location]) {
          dateGroups[date][location] = [];
        }
        dateGroups[date][location].push({ court, time });
      });
      
      let todayData = '';
      let otherData = '';
      let todayDateDisplay = '';
      
      // Process each date group
      Object.entries(dateGroups).forEach(([date, locations]) => {
        // Parse date
        const dateParts = date.split('/');
        const month = parseInt(dateParts[0]);
        const day = parseInt(dateParts[1]);
        const year = parseInt(dateParts[2]);
        
        const dateObj = new Date(year, month - 1, day);
        dateObj.setHours(0, 0, 0, 0);
        
        // Format date for display
        const dateDisplay = `${month}/${day}`;
        
        // Add date with parentheses if not today
        const isToday = dateObj.getTime() === today.getTime();
        const datePrefix = isToday ? '' : `(${dateDisplay})`;
        
        if (isToday) {
          todayDateDisplay = dateDisplay;
        }
        
        // Process each location
        const sortedLocations = Object.keys(locations).sort();
        let sectionText = '';
        
        sortedLocations.forEach((location, index) => {
          const locationData = locations[location];
          
          // Special handling for Mango Park
          if (location.includes('Mango')) {
            sectionText += `Mango: Unavailable until August 2025\n`;
            return;
          }
          
          // Group by time
          const timeGroups = {};
          locationData.forEach(item => {
            if (!timeGroups[item.time]) {
              timeGroups[item.time] = [];
            }
            timeGroups[item.time].push(item.court);
          });
          
          const timeEntries = Object.entries(timeGroups);
          const simpleLocation = simplifyLocation(location);
          
          if (timeEntries.length === 1) {
            const [time, courts] = timeEntries[0];
            sectionText += `${simpleLocation}${datePrefix}: ${courts.join(', ')}: ${time}\n`;
          } else {
            sectionText += `${simpleLocation}${datePrefix}:\n`;
            timeEntries.forEach(([time, courts]) => {
              sectionText += `  ${courts.join(', ')}: ${time}\n`;
            });
          }
          
          if (index < sortedLocations.length - 1) {
            sectionText += '\n';
          }
        });
        
        if (isToday) {
          todayData = sectionText;
        } else {
          otherData += sectionText;
        }
      });
      
      const text = `SNV LT æ•™ç»ƒå åœºä¿¡æ¯ ${currentTab} ${todayDateDisplay}\n${todayData}${otherData}`;
      
      navigator.clipboard.writeText(text).then(() => {
        document.getElementById("copy-toast").style.opacity = 1;
        setTimeout(() => { document.getElementById("copy-toast").style.opacity = 0; }, 1500);
      });
    });
    
    // Add handler for plot copying
    document.getElementById("copy-plot-button").addEventListener("click", () => {
      if (!currentTab) {
        alert("Please select a day and switch to plot view first");
        return;
      }
      
      const canvas = document.getElementById('schedule-plot');
      
      // Show a brief loading message
      const plotToast = document.getElementById("plot-toast");
      plotToast.textContent = "Copying plot...";
      plotToast.style.opacity = 1;
      
      // Detect if mobile
      const isMobile = window.innerWidth <= 768;
      
      // Use html2canvas to capture the canvas
      try {
        // Convert to blob and copy directly from the canvas (no need for html2canvas)
        canvas.toBlob(blob => {
          if (blob) {
            if (isMobile) {
              // For mobile devices, offer the image for download or sharing
              try {
                // Create a temporary link to download the image
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `tennis-courts-${currentTab.toLowerCase()}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Show success message
                plotToast.textContent = "Image saved âœ…";
                setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
              } catch (err) {
                console.error("Error creating downloadable image:", err);
                // Fall back to clipboard copy
                fallbackToCopy();
              }
            } else {
              // Create a ClipboardItem
              const item = new ClipboardItem({ "image/png": blob });
              navigator.clipboard.write([item]).then(() => {
                plotToast.textContent = "Copied plot âœ…";
                setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
              }).catch(err => {
                console.error("Could not copy image: ", err);
                plotToast.textContent = "Copy failed âŒ";
                setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
              });
            }
          } else {
            console.error("Failed to create blob from canvas");
            plotToast.textContent = "Copy failed âŒ";
            setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
          }
        }, 'image/png', 1.0); // 1.0 is max quality
      } catch (err) {
        console.error("Error copying canvas:", err);
        plotToast.textContent = "Copy failed âŒ";
        setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
      }
      
      // Fallback function for mobile clipboard issues
      function fallbackToCopy() {
        try {
          const item = new ClipboardItem({ "image/png": blob });
          navigator.clipboard.write([item]).then(() => {
            plotToast.textContent = "Copied plot âœ…";
            setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
          }).catch(err => {
            console.error("Fallback copy failed:", err);
            plotToast.textContent = "Copy failed âŒ";
            setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
          });
        } catch(err) {
          console.error("Fallback error:", err);
          plotToast.textContent = "Copy failed âŒ";
          setTimeout(() => { plotToast.style.opacity = 0; }, 1500);
        }
      }
    });
    
    // Toggle between table and plot views
    document.getElementById('table-view-btn').addEventListener('click', () => {
      document.getElementById('table-container').style.display = 'block';
      document.getElementById('plot-container').style.display = 'none';
      document.getElementById('table-view-btn').classList.add('active');
      document.getElementById('plot-view-btn').classList.remove('active');
      document.getElementById('copy-plot-button').style.display = 'none';
    });
    
    document.getElementById('plot-view-btn').addEventListener('click', () => {
      document.getElementById('table-container').style.display = 'none';
      document.getElementById('plot-container').style.display = 'block';
      document.getElementById('table-view-btn').classList.remove('active');
      document.getElementById('plot-view-btn').classList.add('active');
      document.getElementById('copy-plot-button').style.display = 'flex';
      
      if (currentTab) {
        createPlot(currentTab);
      }
    });

    const today = new Date();
    const todayDay = expectedDays[today.getDay()];
    const defaultDay = grouped[todayDay] ? todayDay : expectedDays.find(day => grouped[day]);
    if (defaultDay) {
      switchTab(defaultDay);
      // Set the initial day text with abbreviation
      document.querySelector('.tab-buttons').setAttribute('data-day', defaultDay.substring(0, 3));
    }

  } catch (error) {
    console.error("Failed to fetch or render CSV:", error);
    document.getElementById("table-container").innerHTML = "Could not load schedule. Please check network or CSV URL.";
  }
}

fetchAndRenderTable();

// Add this to your existing JavaScript
document.addEventListener('DOMContentLoaded', function() {
    const tabButtons = document.querySelector('.tab-buttons');
    
    // Add click handler for the expand/collapse button
    tabButtons.addEventListener('click', function(e) {
        if (e.target === this || e.target === this.firstElementChild) {
            this.classList.toggle('expanded');
        }
    });
    
    // Close the menu when clicking outside
    document.addEventListener('click', function(e) {
        if (!tabButtons.contains(e.target)) {
            tabButtons.classList.remove('expanded');
        }
    });
});
</script>
<div id="copy-toast" class="copy-toast">Copied text âœ…</div>
<div id="plot-toast" class="copy-toast">Copied plot âœ…</div>
</body>
</html>
